{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar GameObject = require('../GameObject');\n\nvar GetFastValue = require('../../utils/object/GetFastValue');\n\nvar Merge = require('../../utils/object/Merge');\n\nvar SetValue = require('../../utils/object/SetValue');\n\nvar ShaderRender = require('./ShaderRender');\n\nvar TransformMatrix = require('../components/TransformMatrix');\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n * \r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n * \r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *  \r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n * \r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n * \r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n * \r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n * \r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n * \r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n * \r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n */\n\n\nvar Shader = new Class({\n  Extends: GameObject,\n  Mixins: [Components.ComputedSize, Components.Depth, Components.GetBounds, Components.Mask, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, ShaderRender],\n  initialize: function Shader(scene, key, x, y, width, height, textures) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = 0;\n    }\n\n    if (width === undefined) {\n      width = 128;\n    }\n\n    if (height === undefined) {\n      height = 128;\n    }\n\n    GameObject.call(this, scene, 'Shader');\n    /**\r\n     * This Game Object cannot have a blend mode, so skip all checks.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#blendMode\r\n     * @type {integer}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this.blendMode = -1;\n    /**\r\n     * The underlying shader object being used.\r\n     * Empty by default and set during a call to the `setShader` method.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#shader\r\n     * @type {Phaser.Display.BaseShader}\r\n     * @since 3.17.0\r\n     */\n\n    this.shader;\n    var renderer = scene.sys.renderer;\n    /**\r\n     * A reference to the current renderer.\r\n     * Shaders only work with the WebGL Renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#renderer\r\n     * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n     * @since 3.17.0\r\n     */\n\n    this.renderer = renderer;\n    /**\r\n     * The WebGL context belonging to the renderer.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#gl\r\n     * @type {WebGLRenderingContext}\r\n     * @since 3.17.0\r\n     */\n\n    this.gl = renderer.gl;\n    /**\r\n     * Raw byte buffer of vertices this Shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexData\r\n     * @type {ArrayBuffer}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\n    /**\r\n     * The WebGL vertex buffer object this shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexBuffer\r\n     * @type {WebGLBuffer}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\n    /**\r\n     * The WebGL shader program this shader uses.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#program\r\n     * @type {WebGLProgram}\r\n     * @since 3.17.0\r\n     */\n\n    this.program = null;\n    /**\r\n     * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#bytes\r\n     * @type {Uint8Array}\r\n     * @since 3.17.0\r\n     */\n\n    this.bytes = new Uint8Array(this.vertexData);\n    /**\r\n     * Float32 view of the array buffer containing the shaders vertices.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#vertexViewF32\r\n     * @type {Float32Array}\r\n     * @since 3.17.0\r\n     */\n\n    this.vertexViewF32 = new Float32Array(this.vertexData);\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix1 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix2 = new TransformMatrix();\n    /**\r\n     * A temporary Transform Matrix, re-used internally during batching.\r\n     *\r\n     * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n     * @private\r\n     * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n     * @since 3.17.0\r\n     */\n\n    this._tempMatrix3 = new TransformMatrix();\n    /**\r\n     * The view matrix the shader uses during rendering.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#viewMatrix\r\n     * @type {Float32Array}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    /**\r\n     * The projection matrix the shader uses during rendering.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#projectionMatrix\r\n     * @type {Float32Array}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n    /**\r\n     * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n     * creating this shader game object. The uniforms are updated automatically during the render step.\r\n     * \r\n     * The defaults are:\r\n     * \r\n     * `resolution` (2f) - Set to the size of this shader.\r\n     * `time` (1f) - The elapsed game time, in seconds.\r\n     * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n     * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n     * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n     * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#uniforms\r\n     * @type {any}\r\n     * @since 3.17.0\r\n     */\n\n    this.uniforms = {};\n    /**\r\n     * The pointer bound to this shader, if any.\r\n     * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#pointer\r\n     * @type {Phaser.Input.Pointer}\r\n     * @since 3.17.0\r\n     */\n\n    this.pointer = null;\n    /**\r\n     * The cached width of the renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_rendererWidth\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._rendererWidth = renderer.width;\n    /**\r\n     * The cached height of the renderer.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_rendererHeight\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._rendererHeight = renderer.height;\n    /**\r\n     * Internal texture count tracker.\r\n     * \r\n     * @name Phaser.GameObjects.Shader#_textureCount\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this._textureCount = 0;\n    this.setPosition(x, y);\n    this.setSize(width, height);\n    this.setOrigin(0.5, 0.5);\n    this.setShader(key, textures);\n  },\n\n  /**\r\n   * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n   * This will immediately delete the active shader program, if set, and then create a new one\r\n   * with the given source. Finally, the shader uniforms are initialized.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setShader\r\n   * @since 3.17.0\r\n   * \r\n   * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n   * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setShader: function setShader(key, textures) {\n    if (textures === undefined) {\n      textures = [];\n    }\n\n    if (typeof key === 'string') {\n      var cache = this.scene.sys.cache.shader;\n\n      if (!cache.has(key)) {\n        console.warn('Shader missing: ' + key);\n        return this;\n      }\n\n      this.shader = cache.get(key);\n    } else {\n      this.shader = key;\n    }\n\n    var gl = this.gl;\n    var renderer = this.renderer;\n\n    if (this.program) {\n      gl.deleteProgram(this.program);\n    }\n\n    var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);\n    renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix);\n    renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\n    this.program = program;\n    var d = new Date();\n    var defaultUniforms = {\n      resolution: {\n        type: '2f',\n        value: {\n          x: this.width,\n          y: this.height\n        }\n      },\n      time: {\n        type: '1f',\n        value: 0\n      },\n      mouse: {\n        type: '2f',\n        value: {\n          x: this.width / 2,\n          y: this.height / 2\n        }\n      },\n      date: {\n        type: '4fv',\n        value: [d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds()]\n      },\n      sampleRate: {\n        type: '1f',\n        value: 44100.0\n      },\n      iChannel0: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel1: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel2: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      },\n      iChannel3: {\n        type: 'sampler2D',\n        value: null,\n        textureData: {\n          repeat: true\n        }\n      }\n    };\n\n    if (this.shader.uniforms) {\n      this.uniforms = Merge(this.shader.uniforms, defaultUniforms);\n    } else {\n      this.uniforms = defaultUniforms;\n    }\n\n    for (var i = 0; i < 4; i++) {\n      if (textures[i]) {\n        this.setSampler2D('iChannel' + i, textures[i], i);\n      }\n    }\n\n    this.initUniforms();\n    this.projOrtho(0, renderer.width, renderer.height, 0);\n    return this;\n  },\n\n  /**\r\n   * Binds a Phaser Pointer object to this Shader.\r\n   * \r\n   * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n   * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setPointer\r\n   * @since 3.17.0\r\n   * \r\n   * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setPointer: function setPointer(pointer) {\n    this.pointer = pointer;\n    return this;\n  },\n\n  /**\r\n   * Sets this shader to use an orthographic projection matrix.\r\n   * This matrix is stored locally in the `projectionMatrix` property,\r\n   * as well as being bound to the `uProjectionMatrix` uniform.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#projOrtho\r\n   * @since 3.17.0\r\n   *\r\n   * @param {number} left - The left value.\r\n   * @param {number} right - The right value.\r\n   * @param {number} bottom - The bottom value.\r\n   * @param {number} top - The top value.\r\n   */\n  projOrtho: function projOrtho(left, right, bottom, top) {\n    var near = -1000;\n    var far = 1000;\n    var leftRight = 1 / (left - right);\n    var bottomTop = 1 / (bottom - top);\n    var nearFar = 1 / (near - far);\n    var pm = this.projectionMatrix;\n    pm[0] = -2 * leftRight;\n    pm[5] = -2 * bottomTop;\n    pm[10] = 2 * nearFar;\n    pm[12] = (left + right) * leftRight;\n    pm[13] = (top + bottom) * bottomTop;\n    pm[14] = (far + near) * nearFar;\n    var program = this.program;\n    this.renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\n    this._rendererWidth = right;\n    this._rendererHeight = bottom;\n  },\n  // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\n  // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\n\n  /**\r\n   * Initializes all of the uniforms this shader uses.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#initUniforms\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  initUniforms: function initUniforms() {\n    var gl = this.gl;\n    var map = this.renderer.glFuncMap;\n    var program = this.program;\n    this._textureCount = 0;\n\n    for (var key in this.uniforms) {\n      var uniform = this.uniforms[key];\n      var type = uniform.type;\n      var data = map[type];\n      uniform.uniformLocation = gl.getUniformLocation(program, key);\n\n      if (type !== 'sampler2D') {\n        uniform.glMatrix = data.matrix;\n        uniform.glValueLength = data.length;\n        uniform.glFunc = data.func;\n      }\n    }\n  },\n\n  /**\r\n   * Sets a sampler2D uniform on this shader.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setSampler2D\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {integer} [textureIndex=0] - The texture index.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setSampler2D: function setSampler2D(uniformKey, textureKey, textureIndex, textureData) {\n    if (textureIndex === undefined) {\n      textureIndex = 0;\n    }\n\n    var textureManager = this.scene.sys.textures;\n\n    if (textureManager.exists(textureKey)) {\n      var frame = textureManager.getFrame(textureKey);\n      var uniform = this.uniforms[uniformKey];\n      uniform.textureKey = textureKey;\n      uniform.source = frame.source.image;\n      uniform.value = frame.glTexture;\n\n      if (textureData) {\n        uniform.textureData = textureData;\n      }\n\n      this._textureCount = textureIndex;\n      this.initSampler2D(uniform);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets a property of a uniform already present on this shader.\r\n   * \r\n   * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n   * \r\n   * ```javascript\r\n   * shader.setUniform('size.value', 16);\r\n   * ```\r\n   * \r\n   * You can use dot notation to access deeper values, for example:\r\n   * \r\n   * ```javascript\r\n   * shader.setUniform('resolution.value.x', 512);\r\n   * ```\r\n   * \r\n   * The change to the uniform will take effect the next time the shader is rendered.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setUniform\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n   * @param {any} value - The value to set into the uniform.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setUniform: function setUniform(key, value) {\n    SetValue(this.uniforms, key, value);\n    return this;\n  },\n\n  /**\r\n   * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#getUniform\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} key - The key of the uniform to return the value for.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  getUniform: function getUniform(key) {\n    return GetFastValue(this.uniforms, key, null);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel0\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel0: function setChannel0(textureKey, textureData) {\n    return this.setSampler2D('iChannel0', textureKey, 0, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel1\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel1: function setChannel1(textureKey, textureData) {\n    return this.setSampler2D('iChannel1', textureKey, 1, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel2\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel2: function setChannel2(textureKey, textureData) {\n    return this.setSampler2D('iChannel2', textureKey, 2, textureData);\n  },\n\n  /**\r\n   * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n   * \r\n   * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n   * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#setChannel3\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n   * @param {any} [textureData] - Additional texture data.\r\n   * \r\n   * @return {this} This Shader instance.\r\n   */\n  setChannel3: function setChannel3(textureKey, textureData) {\n    return this.setSampler2D('iChannel3', textureKey, 3, textureData);\n  },\n\n  /**\r\n   * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n   * gl texture parameters.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#initSampler2D\r\n   * @private\r\n   * @since 3.17.0\r\n   * \r\n   * @param {any} uniform - The sampler2D uniform to process.\r\n   */\n  initSampler2D: function initSampler2D(uniform) {\n    if (!uniform.value) {\n      return;\n    }\n\n    var gl = this.gl;\n    gl.activeTexture(gl.TEXTURE0 + this._textureCount);\n    gl.bindTexture(gl.TEXTURE_2D, uniform.value); //  Extended texture data\n\n    var data = uniform.textureData;\n\n    if (data) {\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\n      //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\n      //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\n      //  format can be: gl.LUMINANCE or gl.RGBA\n      var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\n      var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\n      var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\n      var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\n      var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\n\n      if (data.repeat) {\n        wrapS = gl.REPEAT;\n        wrapT = gl.REPEAT;\n      }\n\n      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\n\n      if (data.width) {\n        var width = GetFastValue(data, 'width', 512);\n        var height = GetFastValue(data, 'height', 2);\n        var border = GetFastValue(data, 'border', 0); //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\n      } else {\n        //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\n        gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\n      }\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\n    }\n\n    this.renderer.setProgram(this.program);\n    gl.uniform1i(uniform.uniformLocation, this._textureCount);\n    this._textureCount++;\n  },\n\n  /**\r\n   * Synchronizes all of the uniforms this shader uses.\r\n   * Each uniforms gl function is called in turn.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#syncUniforms\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  syncUniforms: function syncUniforms() {\n    var gl = this.gl;\n    var uniforms = this.uniforms;\n    var uniform;\n    var length;\n    var glFunc;\n    var location;\n    var value;\n    var textureCount = 0;\n\n    for (var key in uniforms) {\n      uniform = uniforms[key];\n      glFunc = uniform.glFunc;\n      length = uniform.glValueLength;\n      location = uniform.uniformLocation;\n      value = uniform.value;\n\n      if (length === 1) {\n        if (uniform.glMatrix) {\n          glFunc.call(gl, location, uniform.transpose, value);\n        } else {\n          glFunc.call(gl, location, value);\n        }\n      } else if (length === 2) {\n        glFunc.call(gl, location, value.x, value.y);\n      } else if (length === 3) {\n        glFunc.call(gl, location, value.x, value.y, value.z);\n      } else if (length === 4) {\n        glFunc.call(gl, location, value.x, value.y, value.z, value.w);\n      } else if (uniform.type === 'sampler2D') {\n        gl.activeTexture(gl['TEXTURE' + textureCount]);\n        gl.bindTexture(gl.TEXTURE_2D, value);\n        gl.uniform1i(location, textureCount);\n        textureCount++;\n      }\n    }\n  },\n\n  /**\r\n   * Called automatically during render.\r\n   * \r\n   * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n   * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n   * for flush to be called.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#load\r\n   * @since 3.17.0\r\n   * \r\n   * @param {Phaser.GameObjects.Components.TransformMatrix} matrix2D - The transform matrix to use during rendering.\r\n   */\n  load: function load(matrix2D) {\n    //  ITRS\n    var width = this.width;\n    var height = this.height;\n    var renderer = this.renderer;\n    var program = this.program;\n    var x = -this._displayOriginX;\n    var y = -this._displayOriginY;\n    var vm = this.viewMatrix;\n    vm[0] = matrix2D[0];\n    vm[1] = matrix2D[1];\n    vm[4] = matrix2D[2];\n    vm[5] = matrix2D[3];\n    vm[8] = matrix2D[4];\n    vm[9] = matrix2D[5];\n    vm[12] = vm[0] * x + vm[4] * y;\n    vm[13] = vm[1] * x + vm[5] * y;\n    this.renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix); //  Update common uniforms\n\n    var uniforms = this.uniforms;\n    var res = uniforms.resolution;\n    res.value.x = width;\n    res.value.y = height;\n    uniforms.time.value = renderer.game.loop.getDuration();\n    var pointer = this.pointer;\n\n    if (pointer) {\n      var mouse = uniforms.mouse;\n      var px = pointer.x / width;\n      var py = 1 - pointer.y / height;\n      mouse.value.x = px.toFixed(2);\n      mouse.value.y = py.toFixed(2);\n    }\n\n    this.syncUniforms();\n  },\n\n  /**\r\n   * Called automatically during render.\r\n   * \r\n   * Sets the active shader, loads the vertex buffer and then draws.\r\n   * \r\n   * @method Phaser.GameObjects.Shader#flush\r\n   * @since 3.17.0\r\n   */\n  flush: function flush() {\n    //  Bind\n    var width = this.width;\n    var height = this.height;\n    var program = this.program;\n    var gl = this.gl;\n    var vertexBuffer = this.vertexBuffer;\n    var renderer = this.renderer;\n    var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\n    renderer.setProgram(program);\n    renderer.setVertexBuffer(vertexBuffer);\n    var location = gl.getAttribLocation(program, 'inPosition');\n\n    if (location !== -1) {\n      gl.enableVertexAttribArray(location);\n      gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\n    } //  Draw\n\n\n    var vf = this.vertexViewF32;\n    vf[3] = height;\n    vf[4] = width;\n    vf[5] = height;\n    vf[8] = width;\n    vf[9] = height;\n    vf[10] = width; //  Flush\n\n    var vertexCount = 6;\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\n    gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\n  },\n\n  /**\r\n   * A NOOP method so you can pass a Shader to a Container.\r\n   * Calling this method will do nothing. It is intentionally empty.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setAlpha\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  setAlpha: function setAlpha() {},\n\n  /**\r\n   * A NOOP method so you can pass a Shader to a Container.\r\n   * Calling this method will do nothing. It is intentionally empty.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#setBlendMode\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  setBlendMode: function setBlendMode() {},\n\n  /**\r\n   * Internal destroy handler, called as part of the destroy process.\r\n   *\r\n   * @method Phaser.GameObjects.Shader#preDestroy\r\n   * @protected\r\n   * @since 3.17.0\r\n   */\n  preDestroy: function preDestroy() {\n    var gl = this.gl;\n    gl.deleteProgram(this.program);\n    gl.deleteBuffer(this.vertexBuffer);\n  }\n});\nmodule.exports = Shader;","map":null,"metadata":{},"sourceType":"script"}