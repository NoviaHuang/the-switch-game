{"ast":null,"code":"/**\r\n * @author       Florian Vazelle\r\n * @author       Geoffrey Glaive\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Point = require('../point/Point');\n\nvar CircleToCircle = require('./CircleToCircle');\n/**\r\n * Checks if two Circles intersect and returns the intersection points as a Point object array.\r\n *\r\n * @function Phaser.Geom.Intersects.GetCircleToCircle\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Geom.Circle} circleA - The first Circle to check for intersection.\r\n * @param {Phaser.Geom.Circle} circleB - The second Circle to check for intersection.\r\n * @param {array} [out] - An optional array in which to store the points of intersection.\r\n *\r\n * @return {array} An array with the points of intersection if objects intersect, otherwise an empty array.\r\n */\n\n\nvar GetCircleToCircle = function GetCircleToCircle(circleA, circleB, out) {\n  if (out === undefined) {\n    out = [];\n  }\n\n  if (CircleToCircle(circleA, circleB)) {\n    var x0 = circleA.x;\n    var y0 = circleA.y;\n    var r0 = circleA.radius;\n    var x1 = circleB.x;\n    var y1 = circleB.y;\n    var r1 = circleB.radius;\n    var coefficientA, coefficientB, coefficientC, lambda, x;\n\n    if (y0 === y1) {\n      x = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0) / (2 * (x0 - x1));\n      coefficientA = 1;\n      coefficientB = -2 * y1;\n      coefficientC = x1 * x1 + x * x - 2 * x1 * x + y1 * y1 - r1 * r1;\n      lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;\n\n      if (lambda === 0) {\n        out.push(new Point(x, -coefficientB / (2 * coefficientA)));\n      } else if (lambda > 0) {\n        out.push(new Point(x, (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA)));\n        out.push(new Point(x, (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA)));\n      }\n    } else {\n      var v1 = (x0 - x1) / (y0 - y1);\n      var n = (r1 * r1 - r0 * r0 - x1 * x1 + x0 * x0 - y1 * y1 + y0 * y0) / (2 * (y0 - y1));\n      coefficientA = v1 * v1 + 1;\n      coefficientB = 2 * y0 * v1 - 2 * n * v1 - 2 * x0;\n      coefficientC = x0 * x0 + y0 * y0 + n * n - r0 * r0 - 2 * y0 * n;\n      lambda = coefficientB * coefficientB - 4 * coefficientA * coefficientC;\n\n      if (lambda === 0) {\n        x = -coefficientB / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n      } else if (lambda > 0) {\n        x = (-coefficientB + Math.sqrt(lambda)) / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n        x = (-coefficientB - Math.sqrt(lambda)) / (2 * coefficientA);\n        out.push(new Point(x, n - x * v1));\n      }\n    }\n  }\n\n  return out;\n};\n\nmodule.exports = GetCircleToCircle;","map":null,"metadata":{},"sourceType":"script"}