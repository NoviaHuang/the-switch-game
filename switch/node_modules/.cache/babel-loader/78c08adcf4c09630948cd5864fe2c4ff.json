{"ast":null,"code":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar CircleContains = require('../../geom/circle/Contains');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('./const');\n\nvar Events = require('./events');\n\nvar RadToDeg = require('../../math/RadToDeg');\n\nvar Rectangle = require('../../geom/rectangle/Rectangle');\n\nvar RectangleContains = require('../../geom/rectangle/Contains');\n\nvar Vector2 = require('../../math/Vector2');\n/**\n * @classdesc\n * A Dynamic Arcade Body.\n *\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\n *\n * @class Body\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\n */\n\n\nvar Body = new Class({\n  initialize: function Body(world, gameObject) {\n    var width = gameObject.width ? gameObject.width : 64;\n    var height = gameObject.height ? gameObject.height : 64;\n    /**\n     * The Arcade Physics simulation this Body belongs to.\n     *\n     * @name Phaser.Physics.Arcade.Body#world\n     * @type {Phaser.Physics.Arcade.World}\n     * @since 3.0.0\n     */\n\n    this.world = world;\n    /**\n     * The Game Object this Body belongs to.\n     *\n     * @name Phaser.Physics.Arcade.Body#gameObject\n     * @type {Phaser.GameObjects.GameObject}\n     * @since 3.0.0\n     */\n\n    this.gameObject = gameObject;\n    /**\n     * Transformations applied to this Body.\n     *\n     * @name Phaser.Physics.Arcade.Body#transform\n     * @type {object}\n     * @since 3.4.0\n     */\n\n    this.transform = {\n      x: gameObject.x,\n      y: gameObject.y,\n      rotation: gameObject.angle,\n      scaleX: gameObject.scaleX,\n      scaleY: gameObject.scaleY,\n      displayOriginX: gameObject.displayOriginX,\n      displayOriginY: gameObject.displayOriginY\n    };\n    /**\n     * Whether the Body's boundary is drawn to the debug display.\n     *\n     * @name Phaser.Physics.Arcade.Body#debugShowBody\n     * @type {boolean}\n     * @since 3.0.0\n     */\n\n    this.debugShowBody = world.defaults.debugShowBody;\n    /**\n     * Whether the Body's velocity is drawn to the debug display.\n     *\n     * @name Phaser.Physics.Arcade.Body#debugShowVelocity\n     * @type {boolean}\n     * @since 3.0.0\n     */\n\n    this.debugShowVelocity = world.defaults.debugShowVelocity;\n    /**\n     * The color of this Body on the debug display.\n     *\n     * @name Phaser.Physics.Arcade.Body#debugBodyColor\n     * @type {integer}\n     * @since 3.0.0\n     */\n\n    this.debugBodyColor = world.defaults.bodyDebugColor;\n    /**\n     * Whether this Body is updated by the physics simulation.\n     *\n     * @name Phaser.Physics.Arcade.Body#enable\n     * @type {boolean}\n     * @default true\n     * @since 3.0.0\n     */\n\n    this.enable = true;\n    /**\n     * Whether this Body's boundary is circular (true) or rectangular (false).\n     *\n     * @name Phaser.Physics.Arcade.Body#isCircle\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#setCircle\n     */\n\n    this.isCircle = false;\n    /**\n     * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\n     * The true radius is equal to `halfWidth`.\n     *\n     * @name Phaser.Physics.Arcade.Body#radius\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#setCircle\n     */\n\n    this.radius = 0;\n    /**\n     * The offset of this Body's position from its Game Object's position, in source pixels.\n     *\n     * @name Phaser.Physics.Arcade.Body#offset\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#setOffset\n     */\n\n    this.offset = new Vector2();\n    /**\n     * The position of this Body within the simulation.\n     *\n     * @name Phaser.Physics.Arcade.Body#position\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.position = new Vector2(gameObject.x, gameObject.y);\n    /**\n     * The position of this Body during the previous step.\n     *\n     * @name Phaser.Physics.Arcade.Body#prev\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.prev = new Vector2(gameObject.x, gameObject.y);\n    /**\n     * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\n     *\n     * @name Phaser.Physics.Arcade.Body#allowRotation\n     * @type {boolean}\n     * @default true\n     * @since 3.0.0\n     */\n\n    this.allowRotation = true;\n    /**\n     * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\n     * The Body's rotation controls the `angle` of its Game Object.\n     * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\n     *\n     * @name Phaser.Physics.Arcade.Body#rotation\n     * @type {number}\n     * @since 3.0.0\n     */\n\n    this.rotation = gameObject.angle;\n    /**\n     * The Body's rotation, in degrees, during the previous step.\n     *\n     * @name Phaser.Physics.Arcade.Body#preRotation\n     * @type {number}\n     * @since 3.0.0\n     */\n\n    this.preRotation = gameObject.angle;\n    /**\n     * The width of the Body's boundary, in pixels.\n     * If the Body is circular, this is also the Body's diameter.\n     *\n     * @name Phaser.Physics.Arcade.Body#width\n     * @type {number}\n     * @default 64\n     * @since 3.0.0\n     */\n\n    this.width = width;\n    /**\n     * The height of the Body's boundary, in pixels.\n     * If the Body is circular, this is also the Body's diameter.\n     *\n     * @name Phaser.Physics.Arcade.Body#height\n     * @type {number}\n     * @default 64\n     * @since 3.0.0\n     */\n\n    this.height = height;\n    /**\n     * The unscaled width of the Body, in source pixels, as set by setSize().\n     * The default is the width of the Body's Game Object's texture frame.\n     *\n     * @name Phaser.Physics.Arcade.Body#sourceWidth\n     * @type {number}\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#setSize\n     */\n\n    this.sourceWidth = width;\n    /**\n     * The unscaled height of the Body, in source pixels, as set by setSize().\n     * The default is the height of the Body's Game Object's texture frame.\n     *\n     * @name Phaser.Physics.Arcade.Body#sourceHeight\n     * @type {number}\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#setSize\n     */\n\n    this.sourceHeight = height;\n\n    if (gameObject.frame) {\n      this.sourceWidth = gameObject.frame.realWidth;\n      this.sourceHeight = gameObject.frame.realHeight;\n    }\n    /**\n     * Half the Body's width, in pixels.\n     *\n     * @name Phaser.Physics.Arcade.Body#halfWidth\n     * @type {number}\n     * @since 3.0.0\n     */\n\n\n    this.halfWidth = Math.abs(width / 2);\n    /**\n     * Half the Body's height, in pixels.\n     *\n     * @name Phaser.Physics.Arcade.Body#halfHeight\n     * @type {number}\n     * @since 3.0.0\n     */\n\n    this.halfHeight = Math.abs(height / 2);\n    /**\n     * The center of the Body's boundary.\n     * The midpoint of its `position` (top-left corner) and its bottom-right corner.\n     *\n     * @name Phaser.Physics.Arcade.Body#center\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\n    /**\n     * The Body's velocity, in pixels per second.\n     *\n     * @name Phaser.Physics.Arcade.Body#velocity\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.velocity = new Vector2();\n    /**\n     * The Body's calculated velocity, in pixels per second, at the last step.\n     *\n     * @name Phaser.Physics.Arcade.Body#newVelocity\n     * @type {Phaser.Math.Vector2}\n     * @readonly\n     * @since 3.0.0\n     */\n\n    this.newVelocity = new Vector2();\n    /**\n     * The Body's absolute maximum change in position, in pixels per step.\n     *\n     * @name Phaser.Physics.Arcade.Body#deltaMax\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.deltaMax = new Vector2();\n    /**\n     * The Body's change in velocity, in pixels per second squared.\n     *\n     * @name Phaser.Physics.Arcade.Body#acceleration\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.acceleration = new Vector2();\n    /**\n     * Whether this Body's velocity is affected by its `drag`.\n     *\n     * @name Phaser.Physics.Arcade.Body#allowDrag\n     * @type {boolean}\n     * @default true\n     * @since 3.0.0\n     */\n\n    this.allowDrag = true;\n    /**\n     * Absolute loss of velocity due to movement, in pixels per second squared.\n     * The x and y components are applied separately.\n     *\n     * When `useDamping` is true, this is 1 minus the damping factor.\n     * A value of 1 means the Body loses no velocity.\n     * A value of 0.95 means the Body loses 5% of its velocity per step.\n     * A value of 0.5 means the Body loses 50% of its velocity per step.\n     *\n     * Drag is applied only when `acceleration` is zero.\n     *\n     * @name Phaser.Physics.Arcade.Body#drag\n     * @type {(Phaser.Math.Vector2|number)}\n     * @since 3.0.0\n     */\n\n    this.drag = new Vector2();\n    /**\n     * Whether this Body's position is affected by gravity (local or world).\n     *\n     * @name Phaser.Physics.Arcade.Body#allowGravity\n     * @type {boolean}\n     * @default true\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#gravity\n     * @see Phaser.Physics.Arcade.World#gravity\n     */\n\n    this.allowGravity = true;\n    /**\n     * Acceleration due to gravity (specific to this Body), in pixels per second squared.\n     * Total gravity is the sum of this vector and the simulation's `gravity`.\n     *\n     * @name Phaser.Physics.Arcade.Body#gravity\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.World#gravity\n     */\n\n    this.gravity = new Vector2();\n    /**\n     * Rebound following a collision, relative to 1.\n     *\n     * @name Phaser.Physics.Arcade.Body#bounce\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.bounce = new Vector2();\n    /**\n     * Rebound following a collision with the world boundary, relative to 1.\n     * If null, `bounce` is used instead.\n     *\n     * @name Phaser.Physics.Arcade.Body#worldBounce\n     * @type {?Phaser.Math.Vector2}\n     * @default null\n     * @since 3.0.0\n     */\n\n    this.worldBounce = null; //  If true this Body will dispatch events\n\n    /**\n     * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\n     *\n     * @name Phaser.Physics.Arcade.Body#onWorldBounds\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.World#worldboundsEvent\n     */\n\n    this.onWorldBounds = false;\n    /**\n     * Whether the simulation emits a `collide` event when this Body collides with another.\n     *\n     * @name Phaser.Physics.Arcade.Body#onCollide\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.World#collideEvent\n     */\n\n    this.onCollide = false;\n    /**\n     * Whether the simulation emits an `overlap` event when this Body overlaps with another.\n     *\n     * @name Phaser.Physics.Arcade.Body#onOverlap\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.World#overlapEvent\n     */\n\n    this.onOverlap = false;\n    /**\n     * The Body's absolute maximum velocity, in pixels per second.\n     * The horizontal and vertical components are applied separately.\n     *\n     * @name Phaser.Physics.Arcade.Body#maxVelocity\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.maxVelocity = new Vector2(10000, 10000);\n    /**\n     * The maximum speed this Body is allowed to reach.\n     * \n     * If not negative it limits the scalar value of speed.\n     * \n     * Any negative value means no maximum is being applied.\n     * \n     * @name Phaser.Physics.Arcade.Body#maxSpeed\n     * @type {number}\n     * @since 3.16.0 \n     */\n\n    this.maxSpeed = -1;\n    /**\n     * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\n     * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\n     * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\n     * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\n     *\n     * @name Phaser.Physics.Arcade.Body#friction\n     * @type {Phaser.Math.Vector2}\n     * @since 3.0.0\n     */\n\n    this.friction = new Vector2(1, 0);\n    /**\n     * If this Body is using `drag` for deceleration this property controls how the drag is applied.\n     * If set to `true` drag will use a damping effect rather than a linear approach. If you are\n     * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\n     * the game Asteroids) then you will get a far smoother and more visually correct deceleration\n     * by using damping, avoiding the axis-drift that is prone with linear deceleration.\n     *\n     * If you enable this property then you should use far smaller `drag` values than with linear, as\n     * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\n     * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\n     *\n     * @name Phaser.Physics.Arcade.Body#useDamping\n     * @type {boolean}\n     * @default false\n     * @since 3.10.0\n     */\n\n    this.useDamping = false;\n    /**\n     * The rate of change of this Body's `rotation`, in degrees per second.\n     *\n     * @name Phaser.Physics.Arcade.Body#angularVelocity\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.angularVelocity = 0;\n    /**\n     * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\n     *\n     * @name Phaser.Physics.Arcade.Body#angularAcceleration\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.angularAcceleration = 0;\n    /**\n     * Loss of angular velocity due to angular movement, in degrees per second.\n     *\n     * Angular drag is applied only when angular acceleration is zero.\n     *\n     * @name Phaser.Physics.Arcade.Body#angularDrag\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.angularDrag = 0;\n    /**\n     * The Body's maximum angular velocity, in degrees per second.\n     *\n     * @name Phaser.Physics.Arcade.Body#maxAngular\n     * @type {number}\n     * @default 1000\n     * @since 3.0.0\n     */\n\n    this.maxAngular = 1000;\n    /**\n     * The Body's inertia, relative to a default unit (1).\n     * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\n     *\n     * @name Phaser.Physics.Arcade.Body#mass\n     * @type {number}\n     * @default 1\n     * @since 3.0.0\n     */\n\n    this.mass = 1;\n    /**\n     * The calculated angle of this Body's velocity vector, in degrees, during the last step.\n     *\n     * @name Phaser.Physics.Arcade.Body#angle\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.angle = 0;\n    /**\n     * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\n     *\n     * @name Phaser.Physics.Arcade.Body#speed\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.speed = 0;\n    /**\n     * The direction of the Body's velocity, as calculated during the last step.\n     * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\n     *\n     * @name Phaser.Physics.Arcade.Body#facing\n     * @type {integer}\n     * @since 3.0.0\n     */\n\n    this.facing = CONST.FACING_NONE;\n    /**\n     * Whether this Body can be moved by collisions with another Body.\n     *\n     * @name Phaser.Physics.Arcade.Body#immovable\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n\n    this.immovable = false;\n    /**\n     * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\n     *\n     * @name Phaser.Physics.Arcade.Body#moves\n     * @type {boolean}\n     * @default true\n     * @since 3.0.0\n     */\n\n    this.moves = true;\n    /**\n     * A flag disabling the default horizontal separation of colliding bodies.\n     * Pass your own `collideCallback` to the collider.\n     *\n     * @name Phaser.Physics.Arcade.Body#customSeparateX\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n\n    this.customSeparateX = false;\n    /**\n     * A flag disabling the default vertical separation of colliding bodies.\n     * Pass your own `collideCallback` to the collider.\n     *\n     * @name Phaser.Physics.Arcade.Body#customSeparateY\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n\n    this.customSeparateY = false;\n    /**\n     * The amount of horizontal overlap (before separation), if this Body is colliding with another.\n     *\n     * @name Phaser.Physics.Arcade.Body#overlapX\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.overlapX = 0;\n    /**\n     * The amount of vertical overlap (before separation), if this Body is colliding with another.\n     *\n     * @name Phaser.Physics.Arcade.Body#overlapY\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.overlapY = 0;\n    /**\n     * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\n     *\n     * @name Phaser.Physics.Arcade.Body#overlapR\n     * @type {number}\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this.overlapR = 0;\n    /**\n     * Whether this Body is overlapped with another and both are not moving.\n     *\n     * @name Phaser.Physics.Arcade.Body#embedded\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n\n    this.embedded = false;\n    /**\n     * Whether this Body interacts with the world boundary.\n     *\n     * @name Phaser.Physics.Arcade.Body#collideWorldBounds\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     */\n\n    this.collideWorldBounds = false;\n    /**\n     * Whether this Body is checked for collisions and for which directions.\n     * You can set `checkCollision.none = true` to disable collision checks.\n     *\n     * @name Phaser.Physics.Arcade.Body#checkCollision\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n     * @since 3.0.0\n     */\n\n    this.checkCollision = {\n      none: false,\n      up: true,\n      down: true,\n      left: true,\n      right: true\n    };\n    /**\n     * Whether this Body is colliding with another and in which direction.\n     *\n     * @name Phaser.Physics.Arcade.Body#touching\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n     * @since 3.0.0\n     */\n\n    this.touching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\n     * Whether this Body was colliding with another during the last step, and in which direction.\n     *\n     * @name Phaser.Physics.Arcade.Body#wasTouching\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n     * @since 3.0.0\n     */\n\n    this.wasTouching = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\n     * Whether this Body is colliding with a tile or the world boundary.\n     *\n     * @name Phaser.Physics.Arcade.Body#blocked\n     * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n     * @since 3.0.0\n     */\n\n    this.blocked = {\n      none: true,\n      up: false,\n      down: false,\n      left: false,\n      right: false\n    };\n    /**\n     * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\n     *\n     * @name Phaser.Physics.Arcade.Body#syncBounds\n     * @type {boolean}\n     * @default false\n     * @since 3.0.0\n     * @see Phaser.GameObjects.Components.GetBounds#getBounds\n     */\n\n    this.syncBounds = false;\n    /**\n     * The Body's physics type (dynamic or static).\n     *\n     * @name Phaser.Physics.Arcade.Body#physicsType\n     * @type {integer}\n     * @readonly\n     * @default Phaser.Physics.Arcade.DYNAMIC_BODY\n     * @since 3.0.0\n     */\n\n    this.physicsType = CONST.DYNAMIC_BODY;\n    /**\n     * Whether the Body's position needs updating from its Game Object.\n     *\n     * @name Phaser.Physics.Arcade.Body#_reset\n     * @type {boolean}\n     * @private\n     * @default true\n     * @since 3.0.0\n     */\n\n    this._reset = true;\n    /**\n     * Cached horizontal scale of the Body's Game Object.\n     *\n     * @name Phaser.Physics.Arcade.Body#_sx\n     * @type {number}\n     * @private\n     * @since 3.0.0\n     */\n\n    this._sx = gameObject.scaleX;\n    /**\n     * Cached vertical scale of the Body's Game Object.\n     *\n     * @name Phaser.Physics.Arcade.Body#_sy\n     * @type {number}\n     * @private\n     * @since 3.0.0\n     */\n\n    this._sy = gameObject.scaleY;\n    /**\n     * The calculated change in the Body's horizontal position during the last step.\n     *\n     * @name Phaser.Physics.Arcade.Body#_dx\n     * @type {number}\n     * @private\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this._dx = 0;\n    /**\n     * The calculated change in the Body's vertical position during the last step.\n     *\n     * @name Phaser.Physics.Arcade.Body#_dy\n     * @type {number}\n     * @private\n     * @default 0\n     * @since 3.0.0\n     */\n\n    this._dy = 0;\n    /**\n     * Stores the Game Object's bounds.\n     *\n     * @name Phaser.Physics.Arcade.Body#_bounds\n     * @type {Phaser.Geom.Rectangle}\n     * @private\n     * @since 3.0.0\n     */\n\n    this._bounds = new Rectangle();\n  },\n\n  /**\n   * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\n   * The Body's `position` isn't changed.\n   *\n   * @method Phaser.Physics.Arcade.Body#updateBounds\n   * @since 3.0.0\n   */\n  updateBounds: function updateBounds() {\n    var sprite = this.gameObject; //  Container?\n\n    var transform = this.transform;\n\n    if (sprite.parentContainer) {\n      var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\n      transform.x = matrix.tx;\n      transform.y = matrix.ty;\n      transform.rotation = RadToDeg(matrix.rotation);\n      transform.scaleX = matrix.scaleX;\n      transform.scaleY = matrix.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    } else {\n      transform.x = sprite.x;\n      transform.y = sprite.y;\n      transform.rotation = sprite.angle;\n      transform.scaleX = sprite.scaleX;\n      transform.scaleY = sprite.scaleY;\n      transform.displayOriginX = sprite.displayOriginX;\n      transform.displayOriginY = sprite.displayOriginY;\n    }\n\n    var recalc = false;\n\n    if (this.syncBounds) {\n      var b = sprite.getBounds(this._bounds);\n      this.width = b.width;\n      this.height = b.height;\n      recalc = true;\n    } else {\n      var asx = Math.abs(transform.scaleX);\n      var asy = Math.abs(transform.scaleY);\n\n      if (this._sx !== asx || this._sy !== asy) {\n        this.width = this.sourceWidth * asx;\n        this.height = this.sourceHeight * asy;\n        this._sx = asx;\n        this._sy = asy;\n        recalc = true;\n      }\n    }\n\n    if (recalc) {\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.updateCenter();\n    }\n  },\n\n  /**\n   * Updates the Body's `center` from its `position`, `width`, and `height`.\n   *\n   * @method Phaser.Physics.Arcade.Body#updateCenter\n   * @since 3.0.0\n   */\n  updateCenter: function updateCenter() {\n    this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n  },\n\n  /**\n   * Prepares the Body for a physics step by resetting all the states and syncing the position\n   * with the parent Game Object.\n   * \n   * This method is only ever called once per game step.\n   *\n   * @method Phaser.Physics.Arcade.Body#preUpdate\n   * @since 3.17.0\n   */\n  preUpdate: function preUpdate() {\n    //  Store and reset collision flags\n    this.wasTouching.none = this.touching.none;\n    this.wasTouching.up = this.touching.up;\n    this.wasTouching.down = this.touching.down;\n    this.wasTouching.left = this.touching.left;\n    this.wasTouching.right = this.touching.right;\n    this.touching.none = true;\n    this.touching.up = false;\n    this.touching.down = false;\n    this.touching.left = false;\n    this.touching.right = false;\n    this.blocked.none = true;\n    this.blocked.up = false;\n    this.blocked.down = false;\n    this.blocked.left = false;\n    this.blocked.right = false;\n    this.overlapR = 0;\n    this.overlapX = 0;\n    this.overlapY = 0;\n    this.embedded = false; //  Updates the transform values\n\n    this.updateBounds();\n    var sprite = this.transform;\n    this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\n    this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\n    this.updateCenter();\n    this.rotation = sprite.rotation;\n    this.preRotation = this.rotation;\n\n    if (this._reset) {\n      this.prev.x = this.position.x;\n      this.prev.y = this.position.y;\n    }\n  },\n\n  /**\n   * Performs a single physics step and updates the body velocity, angle, speed and other\n   * properties.\n   * \n   * This method can be called multiple times per game step.\n   * \n   * The results are synced back to the Game Object in `postUpdate`.\n   *\n   * @method Phaser.Physics.Arcade.Body#update\n   * @fires Phaser.Physics.Arcade.World#worldbounds\n   * @since 3.0.0\n   *\n   * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\n   */\n  update: function update(delta) {\n    if (this.moves) {\n      this.world.updateMotion(this, delta);\n      var vx = this.velocity.x;\n      var vy = this.velocity.y;\n      this.newVelocity.set(vx * delta, vy * delta);\n      this.position.add(this.newVelocity);\n      this.updateCenter();\n      this.angle = Math.atan2(vy, vx);\n      this.speed = Math.sqrt(vx * vx + vy * vy); //  Now the update will throw collision checks at the Body\n      //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n      if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds) {\n        this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\n      }\n    }\n\n    this._dx = this.position.x - this.prev.x;\n    this._dy = this.position.y - this.prev.y;\n  },\n\n  /**\n   * Feeds the Body results back into the parent Game Object.\n   * \n   * This method is only ever called once per game step.\n   *\n   * @method Phaser.Physics.Arcade.Body#postUpdate\n   * @since 3.0.0\n   */\n  postUpdate: function postUpdate() {\n    var dx = this.position.x - this.prev.x;\n    var dy = this.position.y - this.prev.y;\n\n    if (this.moves) {\n      var mx = this.deltaMax.x;\n      var my = this.deltaMax.y;\n\n      if (mx !== 0 && dx !== 0) {\n        if (dx < 0 && dx < -mx) {\n          dx = -mx;\n        } else if (dx > 0 && dx > mx) {\n          dx = mx;\n        }\n      }\n\n      if (my !== 0 && dy !== 0) {\n        if (dy < 0 && dy < -my) {\n          dy = -my;\n        } else if (dy > 0 && dy > my) {\n          dy = my;\n        }\n      }\n\n      this.gameObject.x += dx;\n      this.gameObject.y += dy;\n      this._reset = true;\n    }\n\n    if (dx < 0) {\n      this.facing = CONST.FACING_LEFT;\n    } else if (dx > 0) {\n      this.facing = CONST.FACING_RIGHT;\n    }\n\n    if (dy < 0) {\n      this.facing = CONST.FACING_UP;\n    } else if (dy > 0) {\n      this.facing = CONST.FACING_DOWN;\n    }\n\n    this._dx = dx;\n    this._dy = dy;\n\n    if (this.allowRotation) {\n      this.gameObject.angle += this.deltaZ();\n    }\n\n    this.prev.x = this.position.x;\n    this.prev.y = this.position.y;\n  },\n\n  /**\n   * Checks for collisions between this Body and the world boundary and separates them.\n   *\n   * @method Phaser.Physics.Arcade.Body#checkWorldBounds\n   * @since 3.0.0\n   *\n   * @return {boolean} True if this Body is colliding with the world boundary.\n   */\n  checkWorldBounds: function checkWorldBounds() {\n    var pos = this.position;\n    var bounds = this.world.bounds;\n    var check = this.world.checkCollision;\n    var bx = this.worldBounce ? -this.worldBounce.x : -this.bounce.x;\n    var by = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;\n\n    if (pos.x < bounds.x && check.left) {\n      pos.x = bounds.x;\n      this.velocity.x *= bx;\n      this.blocked.left = true;\n      this.blocked.none = false;\n    } else if (this.right > bounds.right && check.right) {\n      pos.x = bounds.right - this.width;\n      this.velocity.x *= bx;\n      this.blocked.right = true;\n      this.blocked.none = false;\n    }\n\n    if (pos.y < bounds.y && check.up) {\n      pos.y = bounds.y;\n      this.velocity.y *= by;\n      this.blocked.up = true;\n      this.blocked.none = false;\n    } else if (this.bottom > bounds.bottom && check.down) {\n      pos.y = bounds.bottom - this.height;\n      this.velocity.y *= by;\n      this.blocked.down = true;\n      this.blocked.none = false;\n    }\n\n    return !this.blocked.none;\n  },\n\n  /**\n   * Sets the offset of the Body's position from its Game Object's position.\n   *\n   * @method Phaser.Physics.Arcade.Body#setOffset\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal offset, in source pixels.\n   * @param {number} [y=x] - The vertical offset, in source pixels.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setOffset: function setOffset(x, y) {\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.offset.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sizes and positions this Body's boundary, as a rectangle.\n   * Modifies the Body `offset` if `center` is true (the default).\n   * Resets the width and height to match current frame, if no width and height provided and a frame is found.\n   *\n   * @method Phaser.Physics.Arcade.Body#setSize\n   * @since 3.0.0\n   *\n   * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\n   * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\n   * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setSize: function setSize(width, height, center) {\n    if (center === undefined) {\n      center = true;\n    }\n\n    var gameObject = this.gameObject;\n\n    if (!width && gameObject.frame) {\n      width = gameObject.frame.realWidth;\n    }\n\n    if (!height && gameObject.frame) {\n      height = gameObject.frame.realHeight;\n    }\n\n    this.sourceWidth = width;\n    this.sourceHeight = height;\n    this.width = this.sourceWidth * this._sx;\n    this.height = this.sourceHeight * this._sy;\n    this.halfWidth = Math.floor(this.width / 2);\n    this.halfHeight = Math.floor(this.height / 2);\n    this.updateCenter();\n\n    if (center && gameObject.getCenter) {\n      var ox = gameObject.displayWidth / 2;\n      var oy = gameObject.displayHeight / 2;\n      this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\n    }\n\n    this.isCircle = false;\n    this.radius = 0;\n    return this;\n  },\n\n  /**\n   * Sizes and positions this Body's boundary, as a circle.\n   *\n   * @method Phaser.Physics.Arcade.Body#setCircle\n   * @since 3.0.0\n   *\n   * @param {number} radius - The radius of the Body, in source pixels.\n   * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\n   * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setCircle: function setCircle(radius, offsetX, offsetY) {\n    if (offsetX === undefined) {\n      offsetX = this.offset.x;\n    }\n\n    if (offsetY === undefined) {\n      offsetY = this.offset.y;\n    }\n\n    if (radius > 0) {\n      this.isCircle = true;\n      this.radius = radius;\n      this.sourceWidth = radius * 2;\n      this.sourceHeight = radius * 2;\n      this.width = this.sourceWidth * this._sx;\n      this.height = this.sourceHeight * this._sy;\n      this.halfWidth = Math.floor(this.width / 2);\n      this.halfHeight = Math.floor(this.height / 2);\n      this.offset.set(offsetX, offsetY);\n      this.updateCenter();\n    } else {\n      this.isCircle = false;\n    }\n\n    return this;\n  },\n\n  /**\n   * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\n   * If the Body had any velocity or acceleration it is lost as a result of calling this.\n   *\n   * @method Phaser.Physics.Arcade.Body#reset\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal position to place the Game Object and Body.\n   * @param {number} y - The vertical position to place the Game Object and Body.\n   */\n  reset: function reset(x, y) {\n    this.stop();\n    var gameObject = this.gameObject;\n    gameObject.setPosition(x, y);\n    gameObject.getTopLeft(this.position);\n    this.prev.copy(this.position);\n    this.rotation = gameObject.angle;\n    this.preRotation = gameObject.angle;\n    this.updateBounds();\n    this.updateCenter();\n  },\n\n  /**\n   * Sets acceleration, velocity, and speed to zero.\n   *\n   * @method Phaser.Physics.Arcade.Body#stop\n   * @since 3.0.0\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  stop: function stop() {\n    this.velocity.set(0);\n    this.acceleration.set(0);\n    this.speed = 0;\n    this.angularVelocity = 0;\n    this.angularAcceleration = 0;\n    return this;\n  },\n\n  /**\n   * Copies the coordinates of this Body's edges into an object.\n   *\n   * @method Phaser.Physics.Arcade.Body#getBounds\n   * @since 3.0.0\n   *\n   * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\n   *\n   * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\n   */\n  getBounds: function getBounds(obj) {\n    obj.x = this.x;\n    obj.y = this.y;\n    obj.right = this.right;\n    obj.bottom = this.bottom;\n    return obj;\n  },\n\n  /**\n   * Tests if the coordinates are within this Body's boundary.\n   *\n   * @method Phaser.Physics.Arcade.Body#hitTest\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal coordinate.\n   * @param {number} y - The vertical coordinate.\n   *\n   * @return {boolean} True if (x, y) is within this Body.\n   */\n  hitTest: function hitTest(x, y) {\n    return this.isCircle ? CircleContains(this, x, y) : RectangleContains(this, x, y);\n  },\n\n  /**\n   * Whether this Body is touching a tile or the world boundary while moving down.\n   *\n   * @method Phaser.Physics.Arcade.Body#onFloor\n   * @since 3.0.0\n   * @see Phaser.Physics.Arcade.Body#blocked\n   *\n   * @return {boolean} True if touching.\n   */\n  onFloor: function onFloor() {\n    return this.blocked.down;\n  },\n\n  /**\n   * Whether this Body is touching a tile or the world boundary while moving up.\n   *\n   * @method Phaser.Physics.Arcade.Body#onCeiling\n   * @since 3.0.0\n   * @see Phaser.Physics.Arcade.Body#blocked\n   *\n   * @return {boolean} True if touching.\n   */\n  onCeiling: function onCeiling() {\n    return this.blocked.up;\n  },\n\n  /**\n   * Whether this Body is touching a tile or the world boundary while moving left or right.\n   *\n   * @method Phaser.Physics.Arcade.Body#onWall\n   * @since 3.0.0\n   * @see Phaser.Physics.Arcade.Body#blocked\n   *\n   * @return {boolean} True if touching.\n   */\n  onWall: function onWall() {\n    return this.blocked.left || this.blocked.right;\n  },\n\n  /**\n   * The absolute (non-negative) change in this Body's horizontal position from the previous step.\n   *\n   * @method Phaser.Physics.Arcade.Body#deltaAbsX\n   * @since 3.0.0\n   *\n   * @return {number} The delta value.\n   */\n  deltaAbsX: function deltaAbsX() {\n    return this._dx > 0 ? this._dx : -this._dx;\n  },\n\n  /**\n   * The absolute (non-negative) change in this Body's vertical position from the previous step.\n   *\n   * @method Phaser.Physics.Arcade.Body#deltaAbsY\n   * @since 3.0.0\n   *\n   * @return {number} The delta value.\n   */\n  deltaAbsY: function deltaAbsY() {\n    return this._dy > 0 ? this._dy : -this._dy;\n  },\n\n  /**\n   * The change in this Body's horizontal position from the previous step.\n   * This value is set during the Body's update phase.\n   *\n   * @method Phaser.Physics.Arcade.Body#deltaX\n   * @since 3.0.0\n   *\n   * @return {number} The delta value.\n   */\n  deltaX: function deltaX() {\n    return this._dx;\n  },\n\n  /**\n   * The change in this Body's vertical position from the previous step.\n   * This value is set during the Body's update phase.\n   *\n   * @method Phaser.Physics.Arcade.Body#deltaY\n   * @since 3.0.0\n   *\n   * @return {number} The delta value.\n   */\n  deltaY: function deltaY() {\n    return this._dy;\n  },\n\n  /**\n   * The change in this Body's rotation from the previous step, in degrees.\n   *\n   * @method Phaser.Physics.Arcade.Body#deltaZ\n   * @since 3.0.0\n   *\n   * @return {number} The delta value.\n   */\n  deltaZ: function deltaZ() {\n    return this.rotation - this.preRotation;\n  },\n\n  /**\n   * Disables this Body and marks it for deletion by the simulation.\n   *\n   * @method Phaser.Physics.Arcade.Body#destroy\n   * @since 3.0.0\n   */\n  destroy: function destroy() {\n    this.enable = false;\n\n    if (this.world) {\n      this.world.pendingDestroy.set(this);\n    }\n  },\n\n  /**\n   * Draws this Body's boundary and velocity, if enabled.\n   *\n   * @method Phaser.Physics.Arcade.Body#drawDebug\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\n   */\n  drawDebug: function drawDebug(graphic) {\n    var pos = this.position;\n    var x = pos.x + this.halfWidth;\n    var y = pos.y + this.halfHeight;\n\n    if (this.debugShowBody) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\n\n      if (this.isCircle) {\n        graphic.strokeCircle(x, y, this.width / 2);\n      } else {\n        graphic.strokeRect(pos.x, pos.y, this.width, this.height);\n      }\n    }\n\n    if (this.debugShowVelocity) {\n      graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\n      graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\n    }\n  },\n\n  /**\n   * Whether this Body will be drawn to the debug display.\n   *\n   * @method Phaser.Physics.Arcade.Body#willDrawDebug\n   * @since 3.0.0\n   *\n   * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\n   */\n  willDrawDebug: function willDrawDebug() {\n    return this.debugShowBody || this.debugShowVelocity;\n  },\n\n  /**\n   * Sets whether this Body collides with the world boundary.\n   * \n   * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Vec2 first.\n   *\n   * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\n   * @since 3.0.0\n   *\n   * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.\n   * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.\n   * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setCollideWorldBounds: function setCollideWorldBounds(value, bounceX, bounceY) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.collideWorldBounds = value;\n    var setBounceX = bounceX !== undefined;\n    var setBounceY = bounceY !== undefined;\n\n    if (setBounceX || setBounceY) {\n      if (!this.worldBounce) {\n        this.worldBounce = new Vector2();\n      }\n\n      if (setBounceX) {\n        this.worldBounce.x = bounceX;\n      }\n\n      if (setBounceY) {\n        this.worldBounce.y = bounceY;\n      }\n    }\n\n    return this;\n  },\n\n  /**\n   * Sets the Body's velocity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setVelocity\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal velocity, in pixels per second.\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setVelocity: function setVelocity(x, y) {\n    this.velocity.set(x, y);\n    x = this.velocity.x;\n    y = this.velocity.y;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal velocity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setVelocityX\n   * @since 3.0.0\n   *\n   * @param {number} value - The velocity, in pixels per second.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setVelocityX: function setVelocityX(value) {\n    this.velocity.x = value;\n    var x = value;\n    var y = this.velocity.y;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical velocity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setVelocityY\n   * @since 3.0.0\n   *\n   * @param {number} value - The velocity, in pixels per second.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setVelocityY: function setVelocityY(value) {\n    this.velocity.y = value;\n    var x = this.velocity.x;\n    var y = value;\n    this.speed = Math.sqrt(x * x + y * y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's maximum velocity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setMaxVelocity\n   * @since 3.10.0\n   *\n   * @param {number} x - The horizontal velocity, in pixels per second.\n   * @param {number} [y=x] - The vertical velocity, in pixels per second.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setMaxVelocity: function setMaxVelocity(x, y) {\n    this.maxVelocity.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the maximum speed the Body can move.\n   *\n   * @method Phaser.Physics.Arcade.Body#setMaxSpeed\n   * @since 3.16.0\n   *\n   * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setMaxSpeed: function setMaxSpeed(value) {\n    this.maxSpeed = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's bounce.\n   *\n   * @method Phaser.Physics.Arcade.Body#setBounce\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal bounce, relative to 1.\n   * @param {number} y - The vertical bounce, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setBounce: function setBounce(x, y) {\n    this.bounce.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal bounce.\n   *\n   * @method Phaser.Physics.Arcade.Body#setBounceX\n   * @since 3.0.0\n   *\n   * @param {number} value - The bounce, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setBounceX: function setBounceX(value) {\n    this.bounce.x = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical bounce.\n   *\n   * @method Phaser.Physics.Arcade.Body#setBounceY\n   * @since 3.0.0\n   *\n   * @param {number} value - The bounce, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setBounceY: function setBounceY(value) {\n    this.bounce.y = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's acceleration.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAcceleration\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal component, in pixels per second squared.\n   * @param {number} y - The vertical component, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAcceleration: function setAcceleration(x, y) {\n    this.acceleration.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal acceleration.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAccelerationX\n   * @since 3.0.0\n   *\n   * @param {number} value - The acceleration, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAccelerationX: function setAccelerationX(value) {\n    this.acceleration.x = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical acceleration.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAccelerationY\n   * @since 3.0.0\n   *\n   * @param {number} value - The acceleration, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAccelerationY: function setAccelerationY(value) {\n    this.acceleration.y = value;\n    return this;\n  },\n\n  /**\n   * Enables or disables drag.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAllowDrag\n   * @since 3.9.0\n   * @see Phaser.Physics.Arcade.Body#allowDrag\n   *\n   * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAllowDrag: function setAllowDrag(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowDrag = value;\n    return this;\n  },\n\n  /**\n   * Enables or disables gravity's effect on this Body.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAllowGravity\n   * @since 3.9.0\n   * @see Phaser.Physics.Arcade.Body#allowGravity\n   *\n   * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAllowGravity: function setAllowGravity(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowGravity = value;\n    return this;\n  },\n\n  /**\n   * Enables or disables rotation.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAllowRotation\n   * @since 3.9.0\n   * @see Phaser.Physics.Arcade.Body#allowRotation\n   *\n   * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAllowRotation: function setAllowRotation(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.allowRotation = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's drag.\n   *\n   * @method Phaser.Physics.Arcade.Body#setDrag\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal component, in pixels per second squared.\n   * @param {number} y - The vertical component, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setDrag: function setDrag(x, y) {\n    this.drag.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal drag.\n   *\n   * @method Phaser.Physics.Arcade.Body#setDragX\n   * @since 3.0.0\n   *\n   * @param {number} value - The drag, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setDragX: function setDragX(value) {\n    this.drag.x = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical drag.\n   *\n   * @method Phaser.Physics.Arcade.Body#setDragY\n   * @since 3.0.0\n   *\n   * @param {number} value - The drag, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setDragY: function setDragY(value) {\n    this.drag.y = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's gravity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setGravity\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal component, in pixels per second squared.\n   * @param {number} y - The vertical component, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setGravity: function setGravity(x, y) {\n    this.gravity.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal gravity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setGravityX\n   * @since 3.0.0\n   *\n   * @param {number} value - The gravity, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setGravityX: function setGravityX(value) {\n    this.gravity.x = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical gravity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setGravityY\n   * @since 3.0.0\n   *\n   * @param {number} value - The gravity, in pixels per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setGravityY: function setGravityY(value) {\n    this.gravity.y = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's friction.\n   *\n   * @method Phaser.Physics.Arcade.Body#setFriction\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal component, relative to 1.\n   * @param {number} y - The vertical component, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setFriction: function setFriction(x, y) {\n    this.friction.set(x, y);\n    return this;\n  },\n\n  /**\n   * Sets the Body's horizontal friction.\n   *\n   * @method Phaser.Physics.Arcade.Body#setFrictionX\n   * @since 3.0.0\n   *\n   * @param {number} value - The friction value, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setFrictionX: function setFrictionX(value) {\n    this.friction.x = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's vertical friction.\n   *\n   * @method Phaser.Physics.Arcade.Body#setFrictionY\n   * @since 3.0.0\n   *\n   * @param {number} value - The friction value, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setFrictionY: function setFrictionY(value) {\n    this.friction.y = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's angular velocity.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAngularVelocity\n   * @since 3.0.0\n   *\n   * @param {number} value - The velocity, in degrees per second.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAngularVelocity: function setAngularVelocity(value) {\n    this.angularVelocity = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's angular acceleration.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\n   * @since 3.0.0\n   *\n   * @param {number} value - The acceleration, in degrees per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAngularAcceleration: function setAngularAcceleration(value) {\n    this.angularAcceleration = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's angular drag.\n   *\n   * @method Phaser.Physics.Arcade.Body#setAngularDrag\n   * @since 3.0.0\n   *\n   * @param {number} value - The drag, in degrees per second squared.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setAngularDrag: function setAngularDrag(value) {\n    this.angularDrag = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's mass.\n   *\n   * @method Phaser.Physics.Arcade.Body#setMass\n   * @since 3.0.0\n   *\n   * @param {number} value - The mass value, relative to 1.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setMass: function setMass(value) {\n    this.mass = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's `immovable` property.\n   *\n   * @method Phaser.Physics.Arcade.Body#setImmovable\n   * @since 3.0.0\n   *\n   * @param {boolean} [value=true] - The value to assign to `immovable`.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setImmovable: function setImmovable(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.immovable = value;\n    return this;\n  },\n\n  /**\n   * Sets the Body's `enable` property.\n   *\n   * @method Phaser.Physics.Arcade.Body#setEnable\n   * @since 3.15.0\n   *\n   * @param {boolean} [value=true] - The value to assign to `enable`.\n   *\n   * @return {Phaser.Physics.Arcade.Body} This Body object.\n   */\n  setEnable: function setEnable(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.enable = value;\n    return this;\n  },\n\n  /**\n   * The Body's horizontal position (left edge).\n   *\n   * @name Phaser.Physics.Arcade.Body#x\n   * @type {number}\n   * @since 3.0.0\n   */\n  x: {\n    get: function get() {\n      return this.position.x;\n    },\n    set: function set(value) {\n      this.position.x = value;\n    }\n  },\n\n  /**\n   * The Body's vertical position (top edge).\n   *\n   * @name Phaser.Physics.Arcade.Body#y\n   * @type {number}\n   * @since 3.0.0\n   */\n  y: {\n    get: function get() {\n      return this.position.y;\n    },\n    set: function set(value) {\n      this.position.y = value;\n    }\n  },\n\n  /**\n   * The left edge of the Body's boundary. Identical to x.\n   *\n   * @name Phaser.Physics.Arcade.Body#left\n   * @type {number}\n   * @readonly\n   * @since 3.0.0\n   */\n  left: {\n    get: function get() {\n      return this.position.x;\n    }\n  },\n\n  /**\n   * The right edge of the Body's boundary.\n   *\n   * @name Phaser.Physics.Arcade.Body#right\n   * @type {number}\n   * @readonly\n   * @since 3.0.0\n   */\n  right: {\n    get: function get() {\n      return this.position.x + this.width;\n    }\n  },\n\n  /**\n   * The top edge of the Body's boundary. Identical to y.\n   *\n   * @name Phaser.Physics.Arcade.Body#top\n   * @type {number}\n   * @readonly\n   * @since 3.0.0\n   */\n  top: {\n    get: function get() {\n      return this.position.y;\n    }\n  },\n\n  /**\n   * The bottom edge of this Body's boundary.\n   *\n   * @name Phaser.Physics.Arcade.Body#bottom\n   * @type {number}\n   * @readonly\n   * @since 3.0.0\n   */\n  bottom: {\n    get: function get() {\n      return this.position.y + this.height;\n    }\n  }\n});\nmodule.exports = Body;","map":null,"metadata":{},"sourceType":"script"}