{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n/**\r\n * @classdesc\r\n * A Geometry Mask can be applied to a Game Object to hide any pixels of it which don't intersect\r\n * a visible pixel from the geometry mask. The mask is essentially a clipping path which can only\r\n * make a masked pixel fully visible or fully invisible without changing its alpha (opacity).\r\n *\r\n * A Geometry Mask uses a Graphics Game Object to determine which pixels of the masked Game Object(s)\r\n * should be clipped. For any given point of a masked Game Object's texture, the pixel will only be displayed\r\n * if the Graphics Game Object of the Geometry Mask has a visible pixel at the same position. The color and\r\n * alpha of the pixel from the Geometry Mask do not matter.\r\n *\r\n * The Geometry Mask's location matches the location of its Graphics object, not the location of the masked objects.\r\n * Moving or transforming the underlying Graphics object will change the mask (and affect the visibility\r\n * of any masked objects), whereas moving or transforming a masked object will not affect the mask.\r\n * You can think of the Geometry Mask (or rather, of its Graphics object) as an invisible curtain placed\r\n * in front of all masked objects which has its own visual properties and, naturally, respects the camera's\r\n * visual properties, but isn't affected by and doesn't follow the masked objects by itself.\r\n *\r\n * @class GeometryMask\r\n * @memberof Phaser.Display.Masks\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - This parameter is not used.\r\n * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics Game Object to use for the Geometry Mask. Doesn't have to be in the Display List.\r\n */\n\n\nvar GeometryMask = new Class({\n  initialize: function GeometryMask(scene, graphicsGeometry) {\n    /**\r\n     * The Graphics object which describes the Geometry Mask.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#geometryMask\r\n     * @type {Phaser.GameObjects.Graphics}\r\n     * @since 3.0.0\r\n     */\n    this.geometryMask = graphicsGeometry;\n    /**\r\n     * Similar to the BitmapMasks invertAlpha setting this to true will then hide all pixels\r\n     * drawn to the Geometry Mask.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#invertAlpha\r\n     * @type {boolean}\r\n     * @since 3.16.0\r\n     */\n\n    this.invertAlpha = false;\n    /**\r\n     * Is this mask a stencil mask?\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#isStencil\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.isStencil = true;\n    /**\r\n     * The current stencil level.\r\n     *\r\n     * @name Phaser.Display.Masks.GeometryMask#level\r\n     * @type {boolean}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this.level = 0;\n  },\n\n  /**\r\n   * Sets a new Graphics object for the Geometry Mask.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#setShape\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.GameObjects.Graphics} graphicsGeometry - The Graphics object which will be used for the Geometry Mask.\r\n   * \r\n   * @return {this} This Geometry Mask\r\n   */\n  setShape: function setShape(graphicsGeometry) {\n    this.geometryMask = graphicsGeometry;\n    return this;\n  },\n\n  /**\r\n   * Sets the `invertAlpha` property of this Geometry Mask.\r\n   * Inverting the alpha essentially flips the way the mask works.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#setInvertAlpha\r\n   * @since 3.17.0\r\n   *\r\n   * @param {boolean} [value=true] - Invert the alpha of this mask?\r\n   * \r\n   * @return {this} This Geometry Mask\r\n   */\n  setInvertAlpha: function setInvertAlpha(value) {\n    if (value === undefined) {\n      value = true;\n    }\n\n    this.invertAlpha = value;\n    return this;\n  },\n\n  /**\r\n   * Renders the Geometry Mask's underlying Graphics object to the OpenGL stencil buffer and enables the stencil test, which clips rendered pixels according to the mask.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#preRenderWebGL\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n   * @param {Phaser.GameObjects.GameObject} child - The Game Object being rendered.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   */\n  preRenderWebGL: function preRenderWebGL(renderer, child, camera) {\n    var gl = renderer.gl; //  Force flushing before drawing to stencil buffer\n\n    renderer.flush();\n\n    if (renderer.maskStack.length === 0) {\n      gl.enable(gl.STENCIL_TEST);\n      gl.clear(gl.STENCIL_BUFFER_BIT);\n      renderer.maskCount = 0;\n    }\n\n    if (renderer.currentCameraMask.mask !== this) {\n      renderer.currentMask.mask = this;\n    }\n\n    renderer.maskStack.push({\n      mask: this,\n      camera: camera\n    });\n    this.applyStencil(renderer, camera, true);\n    renderer.maskCount++;\n  },\n\n  /**\r\n   * Applies the current stencil mask to the renderer.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#applyStencil\r\n   * @since 3.17.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw to.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   * @param {boolean} inc - Is this an INCR stencil or a DECR stencil?\r\n   */\n  applyStencil: function applyStencil(renderer, camera, inc) {\n    var gl = renderer.gl;\n    var geometryMask = this.geometryMask;\n    var level = renderer.maskCount;\n    gl.colorMask(false, false, false, false);\n\n    if (inc) {\n      gl.stencilFunc(gl.EQUAL, level, 0xFF);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);\n    } else {\n      gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\n      gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);\n    } //  Write stencil buffer\n\n\n    geometryMask.renderWebGL(renderer, geometryMask, 0, camera);\n    renderer.flush();\n    gl.colorMask(true, true, true, true);\n    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\n    if (inc) {\n      if (this.invertAlpha) {\n        gl.stencilFunc(gl.NOTEQUAL, level + 1, 0xFF);\n      } else {\n        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);\n      }\n    } else if (this.invertAlpha) {\n      gl.stencilFunc(gl.NOTEQUAL, level, 0xFF);\n    } else {\n      gl.stencilFunc(gl.EQUAL, level, 0xFF);\n    }\n  },\n\n  /**\r\n   * Flushes all rendered pixels and disables the stencil test of a WebGL context, thus disabling the mask for it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#postRenderWebGL\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer instance to draw flush.\r\n   */\n  postRenderWebGL: function postRenderWebGL(renderer) {\n    var gl = renderer.gl;\n    renderer.maskStack.pop();\n    renderer.maskCount--;\n\n    if (renderer.maskStack.length === 0) {\n      //  If this is the only mask in the stack, flush and disable\n      renderer.flush();\n      renderer.currentMask.mask = null;\n      gl.disable(gl.STENCIL_TEST);\n    } else {\n      //  Force flush before disabling stencil test\n      renderer.flush();\n      var prev = renderer.maskStack[renderer.maskStack.length - 1];\n      prev.mask.applyStencil(renderer, prev.camera, false);\n\n      if (renderer.currentCameraMask.mask !== prev.mask) {\n        renderer.currentMask.mask = prev.mask;\n        renderer.currentMask.camera = prev.camera;\n      } else {\n        renderer.currentMask.mask = null;\n      }\n    }\n  },\n\n  /**\r\n   * Sets the clipping path of a 2D canvas context to the Geometry Mask's underlying Graphics object.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#preRenderCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance to set the clipping path on.\r\n   * @param {Phaser.GameObjects.GameObject} mask - The Game Object being rendered.\r\n   * @param {Phaser.Cameras.Scene2D.Camera} camera - The camera the Game Object is being rendered through.\r\n   */\n  preRenderCanvas: function preRenderCanvas(renderer, mask, camera) {\n    var geometryMask = this.geometryMask;\n    renderer.currentContext.save();\n    geometryMask.renderCanvas(renderer, geometryMask, 0, camera, null, null, true);\n    renderer.currentContext.clip();\n  },\n\n  /**\r\n   * Restore the canvas context's previous clipping path, thus turning off the mask for it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#postRenderCanvas\r\n   * @since 3.0.0\r\n   *\r\n   * @param {Phaser.Renderer.Canvas.CanvasRenderer} renderer - The Canvas Renderer instance being restored.\r\n   */\n  postRenderCanvas: function postRenderCanvas(renderer) {\n    renderer.currentContext.restore();\n  },\n\n  /**\r\n   * Destroys this GeometryMask and nulls any references it holds.\r\n   *\r\n   * Note that if a Game Object is currently using this mask it will _not_ automatically detect you have destroyed it,\r\n   * so be sure to call `clearMask` on any Game Object using it, before destroying it.\r\n   *\r\n   * @method Phaser.Display.Masks.GeometryMask#destroy\r\n   * @since 3.7.0\r\n   */\n  destroy: function destroy() {\n    this.geometryMask = null;\n  }\n});\nmodule.exports = GeometryMask;","map":null,"metadata":{},"sourceType":"script"}