{"ast":null,"code":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\nvar ArcadeImage = require('./ArcadeImage');\n\nvar ArcadeSprite = require('./ArcadeSprite');\n\nvar Class = require('../../utils/Class');\n\nvar CONST = require('./const');\n\nvar PhysicsGroup = require('./PhysicsGroup');\n\nvar StaticPhysicsGroup = require('./StaticPhysicsGroup');\n/**\n * @classdesc\n * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.\n * Objects that are created by this Factory are automatically added to the physics world.\n *\n * @class Factory\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics World instance.\n */\n\n\nvar Factory = new Class({\n  initialize: function Factory(world) {\n    /**\n     * A reference to the Arcade Physics World.\n     *\n     * @name Phaser.Physics.Arcade.Factory#world\n     * @type {Phaser.Physics.Arcade.World}\n     * @since 3.0.0\n     */\n    this.world = world;\n    /**\n     * A reference to the Scene this Arcade Physics instance belongs to.\n     *\n     * @name Phaser.Physics.Arcade.Factory#scene\n     * @type {Phaser.Scene}\n     * @since 3.0.0\n     */\n\n    this.scene = world.scene;\n    /**\n     * A reference to the Scene.Systems this Arcade Physics instance belongs to.\n     *\n     * @name Phaser.Physics.Arcade.Factory#sys\n     * @type {Phaser.Scenes.Systems}\n     * @since 3.0.0\n     */\n\n    this.sys = world.scene.sys;\n  },\n\n  /**\n   * Creates a new Arcade Physics Collider object.\n   *\n   * @method Phaser.Physics.Arcade.Factory#collider\n   * @since 3.0.0\n   *\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for collision.\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for collision.\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\n   *\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n   */\n  collider: function collider(object1, object2, collideCallback, processCallback, callbackContext) {\n    return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\n   * Creates a new Arcade Physics Collider Overlap object.\n   *\n   * @method Phaser.Physics.Arcade.Factory#overlap\n   * @since 3.0.0\n   *\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for overlap.\n   * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for overlap.\n   * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\n   * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n   * @param {*} [callbackContext] - The scope in which to call the callbacks.\n   *\n   * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n   */\n  overlap: function overlap(object1, object2, collideCallback, processCallback, callbackContext) {\n    return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);\n  },\n\n  /**\n   * Adds an Arcade Physics Body to the given Game Object.\n   *\n   * @method Phaser.Physics.Arcade.Factory#existing\n   * @since 3.0.0\n   *\n   * @param {Phaser.GameObjects.GameObject} gameObject - A Game Object.\n   * @param {boolean} [isStatic=false] - Create a Static body (true) or Dynamic body (false).\n   *\n   * @return {Phaser.GameObjects.GameObject} The Game Object.\n   */\n  existing: function existing(gameObject, isStatic) {\n    var type = isStatic ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;\n    this.world.enableBody(gameObject, type);\n    return gameObject;\n  },\n\n  /**\n   * Creates a new Arcade Image object with a Static body.\n   *\n   * @method Phaser.Physics.Arcade.Factory#staticImage\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal position of this Game Object in the world.\n   * @param {number} y - The vertical position of this Game Object in the world.\n   * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n   * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n   *\n   * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\n   */\n  staticImage: function staticImage(x, y, key, frame) {\n    var image = new ArcadeImage(this.scene, x, y, key, frame);\n    this.sys.displayList.add(image);\n    this.world.enableBody(image, CONST.STATIC_BODY);\n    return image;\n  },\n\n  /**\n   * Creates a new Arcade Image object with a Dynamic body.\n   *\n   * @method Phaser.Physics.Arcade.Factory#image\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal position of this Game Object in the world.\n   * @param {number} y - The vertical position of this Game Object in the world.\n   * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n   * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n   *\n   * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\n   */\n  image: function image(x, y, key, frame) {\n    var image = new ArcadeImage(this.scene, x, y, key, frame);\n    this.sys.displayList.add(image);\n    this.world.enableBody(image, CONST.DYNAMIC_BODY);\n    return image;\n  },\n\n  /**\n   * Creates a new Arcade Sprite object with a Static body.\n   *\n   * @method Phaser.Physics.Arcade.Factory#staticSprite\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal position of this Game Object in the world.\n   * @param {number} y - The vertical position of this Game Object in the world.\n   * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n   * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n   *\n   * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\n   */\n  staticSprite: function staticSprite(x, y, key, frame) {\n    var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\n    this.sys.displayList.add(sprite);\n    this.sys.updateList.add(sprite);\n    this.world.enableBody(sprite, CONST.STATIC_BODY);\n    return sprite;\n  },\n\n  /**\n   * Creates a new Arcade Sprite object with a Dynamic body.\n   *\n   * @method Phaser.Physics.Arcade.Factory#sprite\n   * @since 3.0.0\n   *\n   * @param {number} x - The horizontal position of this Game Object in the world.\n   * @param {number} y - The vertical position of this Game Object in the world.\n   * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n   * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n   *\n   * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\n   */\n  sprite: function sprite(x, y, key, frame) {\n    var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\n    this.sys.displayList.add(sprite);\n    this.sys.updateList.add(sprite);\n    this.world.enableBody(sprite, CONST.DYNAMIC_BODY);\n    return sprite;\n  },\n\n  /**\n   * Creates a Static Physics Group object.\n   * All Game Objects created by this Group will automatically be static Arcade Physics objects.\n   *\n   * @method Phaser.Physics.Arcade.Factory#staticGroup\n   * @since 3.0.0\n   *\n   * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\n   * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\n   *\n   * @return {Phaser.Physics.Arcade.StaticGroup} The Static Group object that was created.\n   */\n  staticGroup: function staticGroup(children, config) {\n    return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));\n  },\n\n  /**\n   * Creates a Physics Group object.\n   * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.\n   *\n   * @method Phaser.Physics.Arcade.Factory#group\n   * @since 3.0.0\n   *\n   * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\n   * @param {Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\n   *\n   * @return {Phaser.Physics.Arcade.Group} The Group object that was created.\n   */\n  group: function group(children, config) {\n    return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));\n  },\n\n  /**\n   * Destroys this Factory.\n   *\n   * @method Phaser.Physics.Arcade.Factory#destroy\n   * @since 3.5.0\n   */\n  destroy: function destroy() {\n    this.world = null;\n    this.scene = null;\n    this.sys = null;\n  }\n});\nmodule.exports = Factory;","map":null,"metadata":{},"sourceType":"script"}