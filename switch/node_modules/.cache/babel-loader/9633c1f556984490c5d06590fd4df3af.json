{"ast":null,"code":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\nvar Class = require('../../utils/Class');\n\nvar Components = require('../components');\n\nvar DOMElementRender = require('./DOMElementRender');\n\nvar GameObject = require('../GameObject');\n\nvar IsPlainObject = require('../../utils/object/IsPlainObject');\n\nvar RemoveFromDOM = require('../../dom/RemoveFromDOM');\n\nvar Vector4 = require('../../math/Vector4');\n/**\r\n * @classdesc\r\n * DOM Element Game Objects are a way to control and manipulate HTML Elements over the top of your game.\r\n * \r\n * In order for DOM Elements to display you have to enable them by adding the following to your game\r\n * configuration object:\r\n * \r\n * ```javascript\r\n * dom {\r\n *   createContainer: true\r\n * }\r\n * ```\r\n * \r\n * When this is added, Phaser will automatically create a DOM Container div that is positioned over the top\r\n * of the game canvas. This div is sized to match the canvas, and if the canvas size changes, as a result of\r\n * settings within the Scale Manager, the dom container is resized accordingly.\r\n * \r\n * You can create a DOM Element by either passing in DOMStrings, or by passing in a reference to an existing\r\n * Element that you wish to be placed under the control of Phaser. For example:\r\n * \r\n * ```javascript\r\n * this.add.dom(x, y, 'div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n * ```\r\n * \r\n * The above code will insert a div element into the DOM Container at the given x/y coordinate. The DOMString in\r\n * the 4th argument sets the initial CSS style of the div and the final argument is the inner text. In this case,\r\n * it will create a lime colored div that is 220px by 100px in size with the text Phaser in it, in an Arial font.\r\n * \r\n * You should nearly always, without exception, use explicitly sized HTML Elements, in order to fully control\r\n * alignment and positioning of the elements next to regular game content.\r\n * \r\n * Rather than specify the CSS and HTML directly you can use the `load.html` File Loader to load it into the\r\n * cache and then use the `createFromCache` method instead. You can also use `createFromHTML` and various other\r\n * methods available in this class to help construct your elements.\r\n * \r\n * Once the element has been created you can then control it like you would any other Game Object. You can set its\r\n * position, scale, rotation, alpha and other properties. It will move as the main Scene Camera moves and be clipped\r\n * at the edge of the canvas. It's important to remember some limitations of DOM Elements: The obvious one is that\r\n * they appear above or below your game canvas. You cannot blend them into the display list, meaning you cannot have\r\n * a DOM Element, then a Sprite, then another DOM Element behind it.\r\n * \r\n * They also cannot be enabled for input. To do that, you have to use the `addListener` method to add native event\r\n * listeners directly. The final limitation is to do with cameras. The DOM Container is sized to match the game canvas\r\n * entirely and clipped accordingly. DOM Elements respect camera scrolling and scrollFactor settings, but if you\r\n * change the size of the camera so it no longer matches the size of the canvas, they won't be clipped accordingly.\r\n * \r\n * Also, all DOM Elements are inserted into the same DOM Container, regardless of which Scene they are created in.\r\n * \r\n * DOM Elements are a powerful way to align native HTML with your Phaser Game Objects. For example, you can insert\r\n * a login form for a multiplayer game directly into your title screen. Or a text input box for a highscore table.\r\n * Or a banner ad from a 3rd party service. Or perhaps you'd like to use them for high resolution text display and\r\n * UI. The choice is up to you, just remember that you're dealing with standard HTML and CSS floating over the top\r\n * of your game, and should treat it accordingly.\r\n *\r\n * @class DOMElement\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this DOM Element in the world.\r\n * @param {number} [y=0] - The vertical position of this DOM Element in the world.\r\n * @param {(Element|string)} [element] - An existing DOM element, or a string. If a string starting with a # it will do a `getElementById` look-up on the string (minus the hash). Without a hash, it represents the type of element to create, i.e. 'div'.\r\n * @param {(string|any)} [style] - If a string, will be set directly as the elements `style` property value. If a plain object, will be iterated and the values transferred. In both cases the values replacing whatever CSS styles may have been previously set.\r\n * @param {string} [innerText] - If given, will be set directly as the elements `innerText` property value, replacing whatever was there before.\r\n */\n\n\nvar DOMElement = new Class({\n  Extends: GameObject,\n  Mixins: [Components.Alpha, Components.BlendMode, Components.Depth, Components.Origin, Components.ScrollFactor, Components.Transform, Components.Visible, DOMElementRender],\n  initialize: function DOMElement(scene, x, y, element, style, innerText) {\n    GameObject.call(this, scene, 'DOMElement');\n    /**\r\n     * A reference to the parent DOM Container that the Game instance created when it started.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#parent\r\n     * @type {Element}\r\n     * @since 3.17.0\r\n     */\n\n    this.parent = scene.sys.game.domContainer;\n    /**\r\n     * A reference to the HTML Cache.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#cache\r\n     * @type {Phaser.Cache.BaseCache}\r\n     * @since 3.17.0\r\n     */\n\n    this.cache = scene.sys.cache.html;\n    /**\r\n     * The actual DOM Element that this Game Object is bound to. For example, if you've created a `<div>`\r\n     * then this property is a direct reference to that element within the dom.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#node\r\n     * @type {Element}\r\n     * @since 3.17.0\r\n     */\n\n    this.node;\n    /**\r\n     * By default a DOM Element will have its transform, display, opacity, zIndex and blend mode properties\r\n     * updated when its rendered. If, for some reason, you don't want any of these changed other than the\r\n     * CSS transform, then set this flag to `true`. When `true` only the CSS Transform is applied and it's\r\n     * up to you to keep track of and set the other properties as required.\r\n     * \r\n     * This can be handy if, for example, you've a nested DOM Element and you don't want the opacity to be\r\n     * picked-up by any of its children.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#transformOnly\r\n     * @type {boolean}\r\n     * @since 3.17.0\r\n     */\n\n    this.transformOnly = false;\n    /**\r\n     * The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n     * \r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#skewX\r\n     * @type {number}\r\n     * @since 3.17.0\r\n     */\n\n    this.skewX = 0;\n    /**\r\n     * The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n     * \r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#skewY\r\n     * @type {number}\r\n     * @since 3.17.0\r\n     */\n\n    this.skewY = 0;\n    /**\r\n     * A Vector4 that contains the 3D rotation of this DOM Element around a fixed axis in 3D space.\r\n     * \r\n     * All values in the Vector4 are treated as degrees, unless the `rotate3dAngle` property is changed.\r\n     * \r\n     * For more details see the following MDN page:\r\n     * \r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#rotate3d\r\n     * @type {Phaser.Math.Vector4}\r\n     * @since 3.17.0\r\n     */\n\n    this.rotate3d = new Vector4();\n    /**\r\n     * The unit that represents the 3D rotation values. By default this is `deg` for degrees, but can\r\n     * be changed to any supported unit. See this page for further details:\r\n     * \r\n     * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate3d\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#rotate3dAngle\r\n     * @type {string}\r\n     * @since 3.17.0\r\n     */\n\n    this.rotate3dAngle = 'deg';\n    /**\r\n     * The native (un-scaled) width of this Game Object.\r\n     * \r\n     * For a DOM Element this property is read-only.\r\n     * \r\n     * The property `displayWidth` holds the computed bounds of this DOM Element, factoring in scaling.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.width = 0;\n    /**\r\n     * The native (un-scaled) height of this Game Object.\r\n     * \r\n     * For a DOM Element this property is read-only.\r\n     * \r\n     * The property `displayHeight` holds the computed bounds of this DOM Element, factoring in scaling.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.height = 0;\n    /**\r\n     * The computed display width of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n     * \r\n     * The property `width` holds the un-scaled width of this DOM Element.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#displayWidth\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.displayWidth = 0;\n    /**\r\n     * The computed display height of this Game Object, based on the `getBoundingClientRect` DOM call.\r\n     * \r\n     * The property `height` holds the un-scaled height of this DOM Element.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#displayHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.17.0\r\n     */\n\n    this.displayHeight = 0;\n    /**\r\n     * Internal native event handler.\r\n     * \r\n     * @name Phaser.GameObjects.DOMElement#handler\r\n     * @type {number}\r\n     * @private\r\n     * @since 3.17.0\r\n     */\n\n    this.handler = this.dispatchNativeEvent.bind(this);\n    this.setPosition(x, y);\n\n    if (typeof element === 'string') {\n      //  hash?\n      if (element[0] === '#') {\n        this.setElement(element.substr(1), style, innerText);\n      } else {\n        this.createElement(element, style, innerText);\n      }\n    } else if (element) {\n      this.setElement(element, style, innerText);\n    }\n  },\n\n  /**\r\n   * Sets the horizontal and vertical skew values of this DOM Element.\r\n   * \r\n   * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/transform\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setSkew\r\n   * @since 3.17.0\r\n   *\r\n   * @param {number} [x=0] - The angle, in radians, by which to skew the DOM Element on the horizontal axis.\r\n   * @param {number} [y=x] - The angle, in radians, by which to skew the DOM Element on the vertical axis.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setSkew: function setSkew(x, y) {\n    if (x === undefined) {\n      x = 0;\n    }\n\n    if (y === undefined) {\n      y = x;\n    }\n\n    this.skewX = x;\n    this.skewY = y;\n    return this;\n  },\n\n  /**\r\n   * Sets the perspective CSS property of the _parent DOM Container_. This determines the distance between the z=0\r\n   * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n   * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n   * by the value of this property.\r\n   * \r\n   * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n   * \r\n   * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setPerspective\r\n   * @since 3.17.0\r\n   *\r\n   * @param {number} value - The perspective value, in pixels, that determines the distance between the z plane and the user.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setPerspective: function setPerspective(value) {\n    this.parent.style.perspective = value + 'px';\n    return this;\n  },\n\n  /**\r\n   * The perspective CSS property value of the _parent DOM Container_. This determines the distance between the z=0\r\n   * plane and the user in order to give a 3D-positioned element some perspective. Each 3D element with\r\n   * z > 0 becomes larger; each 3D-element with z < 0 becomes smaller. The strength of the effect is determined\r\n   * by the value of this property.\r\n   * \r\n   * For more information see: https://developer.mozilla.org/en-US/docs/Web/CSS/perspective\r\n   * \r\n   * **Changing this value changes it globally for all DOM Elements, as they all share the same parent container.**\r\n   * \r\n   * @name Phaser.GameObjects.DOMElement#perspective\r\n   * @type {number}\r\n   * @since 3.17.0\r\n   */\n  perspective: {\n    get: function get() {\n      return parseFloat(this.parent.style.perspective);\n    },\n    set: function set(value) {\n      this.parent.style.perspective = value + 'px';\n    }\n  },\n\n  /**\r\n   * Adds one or more native DOM event listeners onto the underlying Element of this Game Object.\r\n   * The event is then dispatched via this Game Objects standard event emitter.\r\n   * \r\n   * For example:\r\n   * \r\n   * ```javascript\r\n   * var div = this.add.dom(x, y, element);\r\n   * \r\n   * div.addListener('click');\r\n   * \r\n   * div.on('click', handler);\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#addListener\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} events - The DOM event/s to listen for. You can specify multiple events by separating them with spaces.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  addListener: function addListener(events) {\n    if (this.node) {\n      events = events.split(' ');\n\n      for (var i = 0; i < events.length; i++) {\n        this.node.addEventListener(events[i], this.handler, false);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Removes one or more native DOM event listeners from the underlying Element of this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#removeListener\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} events - The DOM event/s to stop listening for. You can specify multiple events by separating them with spaces.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  removeListener: function removeListener(events) {\n    if (this.node) {\n      events = events.split(' ');\n\n      for (var i = 0; i < events.length; i++) {\n        this.node.removeEventListener(events[i], this.handler);\n      }\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal event proxy to dispatch native DOM Events via this Game Object.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#dispatchNativeEvent\r\n   * @private\r\n   * @since 3.17.0\r\n   *\r\n   * @param {any} event - The native DOM event.\r\n   */\n  dispatchNativeEvent: function dispatchNativeEvent(event) {\n    this.emit(event.type, event);\n  },\n\n  /**\r\n   * Creates a native DOM Element, adds it to the parent DOM Container and then binds it to this Game Object,\r\n   * so you can control it. The `tagName` should be a string and is passed to `document.createElement`:\r\n   * \r\n   * ```javascript\r\n   * this.add.dom().createElement('div');\r\n   * ```\r\n   * \r\n   * For more details on acceptable tag names see: https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement\r\n   * \r\n   * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n   * value as well. Here is an example of a DOMString:\r\n   * \r\n   * ```javascript\r\n   * this.add.dom().createElement('div', 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n   * ```\r\n   * \r\n   * And using a style object:\r\n   * \r\n   * ```javascript\r\n   * var style = {\r\n   *   'background-color': 'lime';\r\n   *   'width': '200px';\r\n   *   'height': '100px';\r\n   *   'font': '48px Arial';\r\n   * };\r\n   * \r\n   * this.add.dom().createElement('div', style, 'Phaser');\r\n   * ```\r\n   * \r\n   * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n   * Any event listeners you may have previously created will need to be re-created after this call.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#createElement\r\n   * @since 3.17.0\r\n   *\r\n   * @param {string} tagName - A string that specifies the type of element to be created. The nodeName of the created element is initialized with the value of tagName. Don't use qualified names (like \"html:a\") with this method.\r\n   * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n   * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  createElement: function createElement(tagName, style, innerText) {\n    return this.setElement(document.createElement(tagName), style, innerText);\n  },\n\n  /**\r\n   * Binds a new DOM Element to this Game Object. If this Game Object already has an Element it is removed from the DOM\r\n   * entirely first. Any event listeners you may have previously created will need to be re-created on the new element.\r\n   * \r\n   * The `element` argument you pass to this method can be either a string tagName:\r\n   * \r\n   * ```javascript\r\n   * <h1 id=\"heading\">Phaser</h1>\r\n   *\r\n   * this.add.dom().setElement('heading');\r\n   * ```\r\n   * \r\n   * Or a reference to an Element instance:\r\n   * \r\n   * ```javascript\r\n   * <h1 id=\"heading\">Phaser</h1>\r\n   *\r\n   * var h1 = document.getElementById('heading');\r\n   * \r\n   * this.add.dom().setElement(h1);\r\n   * ```\r\n   * \r\n   * You can also pass in a DOMString or style object to set the CSS on the created element, and an optional `innerText`\r\n   * value as well. Here is an example of a DOMString:\r\n   * \r\n   * ```javascript\r\n   * this.add.dom().setElement(h1, 'background-color: lime; width: 220px; height: 100px; font: 48px Arial', 'Phaser');\r\n   * ```\r\n   * \r\n   * And using a style object:\r\n   * \r\n   * ```javascript\r\n   * var style = {\r\n   *   'background-color': 'lime';\r\n   *   'width': '200px';\r\n   *   'height': '100px';\r\n   *   'font': '48px Arial';\r\n   * };\r\n   * \r\n   * this.add.dom().setElement(h1, style, 'Phaser');\r\n   * ```\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setElement\r\n   * @since 3.17.0\r\n   *\r\n   * @param {(string|Element)} element - If a string it is passed to `getElementById()`, or it should be a reference to an existing Element.\r\n   * @param {(string|any)} [style] - Either a DOMString that holds the CSS styles to be applied to the created element, or an object the styles will be ready from.\r\n   * @param {string} [innerText] - A DOMString that holds the text that will be set as the innerText of the created element.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setElement: function setElement(element, style, innerText) {\n    //  Already got an element? Remove it first\n    this.removeElement();\n    var target;\n\n    if (typeof element === 'string') {\n      //  hash?\n      if (element[0] === '#') {\n        element = element.substr(1);\n      }\n\n      target = document.getElementById(element);\n    } else if (typeof element === 'object' && element.nodeType === 1) {\n      target = element;\n    }\n\n    if (!target) {\n      return this;\n    }\n\n    this.node = target; //  style can be empty, a string or a plain object\n\n    if (style && IsPlainObject(style)) {\n      for (var key in style) {\n        target.style[key] = style[key];\n      }\n    } else if (typeof style === 'string') {\n      target.style = style;\n    } //  Add / Override the values we need\n\n\n    target.style.zIndex = '0';\n    target.style.display = 'inline';\n    target.style.position = 'absolute'; //  Node handler\n\n    target.phaser = this;\n\n    if (this.parent) {\n      this.parent.appendChild(target);\n    } //  InnerText\n\n\n    if (innerText) {\n      target.innerText = innerText;\n    }\n\n    return this.updateSize();\n  },\n\n  /**\r\n   * Takes a block of html from the HTML Cache, that has previously been preloaded into the game, and then\r\n   * creates a DOM Element from it. The loaded HTML is set as the `innerHTML` property of the created\r\n   * element.\r\n   * \r\n   * Assume the following html is stored in a file called `loginform.html`:\r\n   * \r\n   * ```html\r\n   * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n   * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n   * ```\r\n   * \r\n   * Which is loaded into your game using the cache key 'login':\r\n   * \r\n   * ```javascript\r\n   * this.load.html('login', 'assets/loginform.html');\r\n   * ```\r\n   * \r\n   * You can create a DOM Element from it using the cache key:\r\n   * \r\n   * ```javascript\r\n   * this.add.dom().createFromCache('login');\r\n   * ```\r\n   * \r\n   * The optional `elementType` argument controls the container that is created, into which the loaded html is inserted.\r\n   * The default is a plain `div` object, but any valid tagName can be given.\r\n   * \r\n   * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n   * Any event listeners you may have previously created will need to be re-created after this call.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#createFromCache\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} The key of the html cache entry to use for this DOM Element.\r\n   * @param {string} [tagName='div'] - The tag name of the element into which all of the loaded html will be inserted. Defaults to a plain div tag.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  createFromCache: function createFromCache(key, tagName) {\n    var html = this.cache.get(key);\n\n    if (html) {\n      this.createFromHTML(html, tagName);\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Takes a string of html and then creates a DOM Element from it. The HTML is set as the `innerHTML`\r\n   * property of the created element.\r\n   * \r\n   * ```javascript\r\n   * let form = `\r\n   * <input type=\"text\" name=\"nameField\" placeholder=\"Enter your name\" style=\"font-size: 32px\">\r\n   * <input type=\"button\" name=\"playButton\" value=\"Let's Play\" style=\"font-size: 32px\">\r\n   * `;\r\n   * ```\r\n   * \r\n   * You can create a DOM Element from it using the string:\r\n   * \r\n   * ```javascript\r\n   * this.add.dom().createFromHTML(form);\r\n   * ```\r\n   * \r\n   * The optional `elementType` argument controls the type of container that is created, into which the html is inserted.\r\n   * The default is a plain `div` object, but any valid tagName can be given.\r\n   * \r\n   * If this Game Object already has an Element, it is removed from the DOM entirely first.\r\n   * Any event listeners you may have previously created will need to be re-created after this call.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#createFromHTML\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} A string of html to be set as the `innerHTML` property of the created element.\r\n   * @param {string} [tagName='div'] - The tag name of the element into which all of the html will be inserted. Defaults to a plain div tag.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  createFromHTML: function createFromHTML(html, tagName) {\n    if (tagName === undefined) {\n      tagName = 'div';\n    } //  Already got an element? Remove it first\n\n\n    this.removeElement();\n    var element = document.createElement(tagName);\n    this.node = element;\n    element.style.zIndex = '0';\n    element.style.display = 'inline';\n    element.style.position = 'absolute'; //  Node handler\n\n    element.phaser = this;\n\n    if (this.parent) {\n      this.parent.appendChild(element);\n    }\n\n    element.innerHTML = html;\n    return this.updateSize();\n  },\n\n  /**\r\n   * Removes the current DOM Element bound to this Game Object from the DOM entirely and resets the\r\n   * `node` property of this Game Object to be `null`.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#removeElement\r\n   * @since 3.17.0\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  removeElement: function removeElement() {\n    if (this.node) {\n      RemoveFromDOM(this.node);\n      this.node = null;\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Internal method that calls `getBoundingClientRect` on the `node` and then sets the bounds width\r\n   * and height into the `displayWidth` and `displayHeight` properties, and the `clientWidth` and `clientHeight`\r\n   * values into the `width` and `height` properties respectively.\r\n   * \r\n   * This is called automatically whenever a new element is created or set.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#updateSize\r\n   * @since 3.17.0\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  updateSize: function updateSize() {\n    var node = this.node;\n    var nodeBounds = node.getBoundingClientRect();\n    this.width = node.clientWidth;\n    this.height = node.clientHeight;\n    this.displayWidth = nodeBounds.width || 0;\n    this.displayHeight = nodeBounds.height || 0;\n    return this;\n  },\n\n  /**\r\n   * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n   * them, looking for the first one that has a property matching the given key and value. It then returns this child\r\n   * if found, or `null` if not.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#getChildByProperty\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} property - The property to search the children for.\r\n   * @param {string} value - The value the property must strictly equal.\r\n   * \r\n   * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n   */\n  getChildByProperty: function getChildByProperty(property, value) {\n    if (this.node) {\n      var children = this.node.querySelectorAll('*');\n\n      for (var i = 0; i < children.length; i++) {\n        if (children[i][property] === value) {\n          return children[i];\n        }\n      }\n    }\n\n    return null;\n  },\n\n  /**\r\n   * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n   * them, looking for the first one that has a matching id. It then returns this child if found, or `null` if not.\r\n   * \r\n   * Be aware that class and id names are case-sensitive.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#getChildByID\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} id - The id to search the children for.\r\n   * \r\n   * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n   */\n  getChildByID: function getChildByID(id) {\n    return this.getChildByProperty('id', id);\n  },\n\n  /**\r\n   * Gets all children from this DOM Elements node, using `querySelectorAll('*')` and then iterates through\r\n   * them, looking for the first one that has a matching name. It then returns this child if found, or `null` if not.\r\n   * \r\n   * Be aware that class and id names are case-sensitive.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#getChildByName\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} name - The name to search the children for.\r\n   * \r\n   * @return {?Element} The first matching child DOM Element, or `null` if not found.\r\n   */\n  getChildByName: function getChildByName(name) {\n    return this.getChildByProperty('name', name);\n  },\n\n  /**\r\n   * Sets the `className` property of the DOM Element node and updates the internal sizes.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setClassName\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} className - A string representing the class or space-separated classes of the element.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setClassName: function setClassName(className) {\n    if (this.node) {\n      this.node.className = className;\n      this.updateSize();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the `innerText` property of the DOM Element node and updates the internal sizes.\r\n   * \r\n   * Note that only certain types of Elements can have `innerText` set on them.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setText\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} text - A DOMString representing the rendered text content of the element.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setText: function setText(text) {\n    if (this.node) {\n      this.node.innerText = text;\n      this.updateSize();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Sets the `innerHTML` property of the DOM Element node and updates the internal sizes.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#setHTML\r\n   * @since 3.17.0\r\n   * \r\n   * @param {string} html - A DOMString of html to be set as the `innerHTML` property of the element.\r\n   * \r\n   * @return {this} This DOM Element instance.\r\n   */\n  setHTML: function setHTML(html) {\n    if (this.node) {\n      this.node.innerHTML = html;\n      this.updateSize();\n    }\n\n    return this;\n  },\n\n  /**\r\n   * Runs internal update tasks.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#preUpdate\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  preUpdate: function preUpdate() {\n    var parent = this.parentContainer;\n    var node = this.node;\n\n    if (node && parent && !parent.willRender()) {\n      node.style.display = 'none';\n    }\n  },\n\n  /**\r\n   * Compares the renderMask with the renderFlags to see if this Game Object will render or not.\r\n   * \r\n   * DOMElements always return `true` as they need to still set values during the render pass, even if not visible.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#willRender\r\n   * @since 3.17.0\r\n   *\r\n   * @return {boolean} `true` if the Game Object should be rendered, otherwise `false`.\r\n   */\n  willRender: function willRender() {\n    return true;\n  },\n\n  /**\r\n   * Handles the pre-destroy step for the DOM Element, which removes the underlying node from the DOM.\r\n   *\r\n   * @method Phaser.GameObjects.DOMElement#preDestroy\r\n   * @private\r\n   * @since 3.17.0\r\n   */\n  preDestroy: function preDestroy() {\n    this.removeElement();\n  }\n});\nmodule.exports = DOMElement;","map":null,"metadata":{},"sourceType":"script"}